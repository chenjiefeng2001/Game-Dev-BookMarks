本篇文章是对于书籍*Game Engine Architecture*的具体解读
## 第一部分 基础
本书目标：
- 如何正确构建一个能够用在工业生产中的游戏引擎
- 游戏开发团队在现实世界中是如何进行组织和工作的
- 游戏引擎中有什么新的子系统以及采用何种设计模式
- 每个主要的子系统的典型需求
- 那些子系统与类型或者游戏无关，哪些又反过来与游戏类型有关
- 游戏引擎通常结束且游戏开始的地方

> ### 预备知识
> 在接下来往下看之前，请确保具有以下的几个预备知识：
> - 线性代数基础
> - 矩阵数学
> - 三角函数的计算
> - 基础代码知识(大部分是C++)

### 典型游戏团队的结构
对于一个典型的游戏团队，应该具有以下的几个职位：
1. 工程师
	工程师是构建程序的主力，没有工程师就没有游戏的程序
2. 艺术家
	用于往游戏程序中添加资产
3. 游戏设计师
	对游戏的关卡、地图等进行设计调控，以确保玩家能进入心流
4. 生产者
	生产者
5.  其他人员
	其他闲杂人员
6. 出版商和工作室
	用于发行游戏和对资金进行管理

### 一些相关定义
1. 游戏的定义
游戏的定义请参考其他的书籍，这里不做探讨。
 2. 游戏引擎的定义
可以说，数据驱动的架构正是游戏引擎与一款游戏而非引擎的软件之间的区别。具有一定的可复用性和

### 不同游戏类型的引擎差异
对于游戏引擎来说，不同的游戏使用的游戏引擎具有的子系统也不尽相同。以下列举对于每个游戏类型来说游戏引擎的侧重点：

1. 第一人称射击游戏(FPS):
	- 灵敏的**摄像头控制/瞄准机制**
	- 玩家的*虚拟手臂*，和武器的高保真动画
	-  各种**强大的**手持武器
	- 宽容的玩家角色**运动和碰撞模型**
	- 非玩家角色的**高保真动画和AI**
	- 小规模在线多人游戏功能以及无处不在的“死亡竞赛”游戏模式
> 当然，要让玩家沉浸在超现实的游戏世界中，需要的不仅仅是优化的高质量图形技术。角色动画、音频和音乐、刚体物理、游戏内过场动画以及众多其他技术，对于第一人称射击游戏来说都必须是尖端的。因此，这类游戏对技术的要求在业内堪称最严格、最广泛。
> 第一人称射击游戏所采用的渲染技术几乎总是经过高度优化，并根据特定类型的渲染环境进行精心调整。例如，室内“地下城探索”游戏通常采用二进制空间分区树或基于传送门的渲染系统。户外 FPS 游戏则使用其他类型的渲染优化，例如遮挡剔除，即对游戏世界进行离线分区，手动或自动指定每个源扇区中可见的目标扇区。
2. 平台游戏和其他第三人称游戏
> 第三人称角色扮演游戏与第一人称射击游戏有很多共同之处，但第三人称角色扮演游戏更注重主角的能力和移动方式。此外，第三人称角色扮演游戏要求玩家角色拥有高保真度的全身角色动画，这与典型的第一人称射击游戏对“悬浮手臂”动画的要求相对低一些。需要注意的是，几乎所有第一人称射击游戏都包含在线多人游戏组件，因此除了第一人称手臂动画外，还必须渲染玩家角色的全身动画。然而，这些第一人称射击游戏玩家角色的保真度通常无法与同类游戏中非玩家角色的保真度相比，也无法与第三人称游戏中玩家角色的保真度相比。
> 在平台游戏中，主角通常采用卡通风格，并非特别逼真或高分辨率。然而，第三人称射击游戏通常以高度逼真的人形玩家角色为特色。在这两种情况下，玩家角色通常都拥有非常丰富的动作和动画。
- 移动平台、梯子、绳索和棚架等有趣的**运动模式**
- 类似谜题的**环境元素**
- 第三人称“**跟随摄像机**”，其焦点始终*集中在玩家角色上*，其旋转通常由人类玩家通过右侧游戏手柄摇杆（在游戏机上）或鼠标（在 PC 上——请注意，虽然 PC 上有许多流行的第三人称射击游戏，但平台游戏类型几乎只存在于游戏机上）控制
- 一个**复杂的相机碰撞系统**，用于**确保视点永远不会“剪切”背景几何或动态前景物体**
### 格斗游戏
通常为双人游戏，在游玩时一般是在一个场地内进行互相攻击。
1. 在传统的格斗游戏上通常聚焦于：
	- 丰富的战斗动画
	- 准确的命中检测
	- 能够检测复杂按钮和操纵杆组合的用户输入系统
	- 人群背景板，但背景相对静止
2.  现代格斗游戏主要聚焦于：
	- 高清人物图形
	- 具有地下散射和汗液效果的逼真的皮肤着色器
	- 逼真的灯光和粒子效果
	- 高保真角色动画
	- 基于物理的角色布料和头发模拟
> 值得注意的是，一些格斗游戏，例如 Ninja Theory 的《天剑》和育碧蒙特利尔工作室的《荣耀战魂》，其背景设定在一个大规模的虚拟世界，而非一个封闭的竞技场中。事实上，许多人认为格斗游戏是一个独立的游戏类型，有时被称为“格斗游戏”。这类格斗游戏的技术要求可能更类似于第三人称射击游戏或策略游戏。

### 赛车游戏
赛车游戏主要专注于：
- 在渲染远处的背景元素时，会使用各种“技巧”，例如使用二维卡片来表示树木、丘陵和山脉
- 赛道通常被分解成相对简单的二维区域，称为“扇区”。这些数据结构用于优化渲染和可见性判断，辅助人工智能和非人为控制车辆的路径查找，以及解决许多其他技术问题
- 摄像机通常跟随车辆后方，以便第三人称视角，或者有时位于驾驶舱内的第一人称视角
- 当赛道涉及隧道和其他“狭窄”空间时，通常需要付出很大努力来确保摄像机不会与背景几何形状发生碰撞

### 策略游戏
*策略游戏玩家通常无法为了观察远距离而大幅改变视角。这种限制使得开发者能够在策略游戏的渲染引擎中运用各种优化*。该类型的老游戏采用**基于网格（基于单元）的世界构建**，并使用正交投影来大大简化渲染器。现代策略游戏有时会使用透视投影和真实的 3D 世界，但它们仍可能采用网格布局系统来确保单位和背景元素（例如建筑物）彼此正确对齐。
常见的关注点在于：
- 每个单元的分辨率相对较低，因此游戏可以同时在屏幕上支持大量单元
- 高度场地形通常是游戏设计和玩游戏的画布
- 除了部署自己的部队之外，玩家通常还可以在地形上建造新建筑
- 用户交互通常是通过单击和基于区域的单位选择，加上包含命令、设备、单位类型、建筑类型等的菜单或工具栏

### 大型多人在线游戏(MMORPG)
MMO 被定义为**支持大量同时玩家（从数千到数十万）的游戏**，通常所有玩家都在一个**非常庞大、持久的虚拟世界**中游戏.所有大型多人在线游戏的核心是一个非常强大的服务器集群。这些服务器维护着游戏世界的权威状态，管理用户登录和退出游戏，提供用户间聊天或 IP 语音（VoIP）服务等等。几乎所有的 MMOG 都需要用户支付某种形式的定期订阅费才能玩，并且它们可能还会在游戏世界内或游戏外提供微交易。因此，中央服务器最重要的角色可能是**处理账单和微交易**，这些*微交易*是游戏开发者主要的收入来源。

> 我们在这里应该指出，最近流行的游戏《绝地求生》（PUBG）推广了一个名为“大逃杀”的子类型。这种游戏模糊了普通多人射击游戏和大型多人在线游戏之间的界限，因为它们通常将大约 100 名玩家放在一个在线世界中相互对抗，采用基于生存的“最后一人站立”的玩法风格。

### 虚拟混合游戏
虚拟混合游戏通常为MR或者VR游戏，其主要关注：
- 立体渲染。VR 游戏需要为每只眼睛渲染场景两次。这使必须渲染的图形基元数量翻倍，尽管图形管道的其他方面，如可见性剔除，每帧只需执行一次，因为眼睛彼此靠得比较近。因此，与在分屏多人模式中渲染相同游戏相比，VR 游戏的渲染成本并不是那么高，但渲染每帧两次，从两个（略有）不同的虚拟摄像机进行渲染的原则是相同的
- **非常高的帧率**
- 导航问题



## 第二章 工具箱
这里提供一些工具来帮助搭建游戏引擎。
1. 版本控制
	常见的版本控制系统：
	- 源代码控制系统(SCCS)
	- 版本控制系统(RCS)
	- 并发版本系统(CVS)
	- Subversion
	- Git(**推荐**)

2. 编译器、链接器和集成开发环境
这部分略过，已经构建过一次项目

## 第三章 游戏软件工程基础
本章目标：
- 回顾有关游戏软件工程的基础知识

### C++回顾和最佳实践
C++是目前游戏业界的主要语言，因此本书主要关注C++，当然，其他语言也是十分重要的

#### 面向对象编程简要回顾
1. 类和对象
类是一个**属性（数据）和行为（代码）的集合**，这些属性和行为共同构成一个有用、有意义的整体。
> 类是一个规范，描述了类中各个实例（称为对象）的构造方式。
2. 封装
封装意味着黑盒子，即对象仅向外界展示有限的接口；对象内部状态和实现细节被隐藏起来。封装简化了类的使用者的生活，因为他们只需要理解类的有限接口，而不需要了解其复杂的实现细节。
3. 继承
继承**允许新类被定义为现有类的扩展**。新类修改或扩展了现有类的数据、接口和/或行为。
	1. 多重继承
	一些语言支持多重继承（MI），这意味着一个类可以有多个父类。**理论上MI可以非常优雅，但在实践中这种设计通常会导致非常的混乱**。
	2. 多态性
	*多态性是一种语言特性*，它允许通过单个公共接口来操作不同类型的对象集合。公共接口使得异构对象集合从使用该接口的代码的角度来看显得是同构的。、
	3. 聚合与组合
	组合是指**使用一组相互作用的对象来完成一项高级任务**。组合在类之间创建了一个“有-个”或“使用-个”的关系。
4. 设计模式
当同一种类型的问题反复出现，许多不同的程序员都采用非常相似的解决方案时，我们就说一个设计模式已经出现，以下是一些常见的设计模式：
- **单例模式**。这种模式确保一个特定的类只有一个实例(单例实例)，并提供一个全局访问点。
- **迭代器**。迭代器提供了一种高效的方式来访问集合中的各个元素，而无需暴露集合的底层结构实现。迭代器“知道”集合的实现细节，因此用户不必知道。
- 抽象工厂。抽象工厂提供了一种接口，用于创建一系列相关的或者依赖的类，而无需指定它们的具体类。
**情节工和RAII**
这是一种十分有用的设计模式示例，在RAII模式中，资源的获取和释放分别绑定到类的构造函数和析构函数中。*这可以防止程序员不小心忘记释放资源——你只需构造一个类的局部实例来获取资源，让它出作用域即可自动释放*
#### C++ 语言标准化
这里**略过**。


### 捕获和处理错误
在游戏引擎中，有几种方法可以捕获和处理错误的情况。作为一名游戏程序员，理解这些不同的机制
、它们的优缺点以及何时使用每种机制非常重要。

##### 错误类型
1. 用户错误
用户错误发生在程序**用户执行不正确操作时**，例如输入无效数据、尝试打开不存在的文件等
2. 程序员错误
	程序员错误是代码本身的错误的结果。尽管它可能是由用户的行为触发的，但尝试打开一个不存在的文件，程序员的本质错误在于，**如果程序员没有犯错误，这个问题本可以避免，而且用户有合理的期望，即程序应该优雅地处理这种情况**。

#### 处理开发者错误
对于游戏引擎来说，用户主要为游戏制作人，这些用户所引起的错误大概率为某种无效的资源所引起。
一方面，似乎有必要防止不良游戏资源停留过久，另一方面，游戏开发是一个混乱且迭代的过程，一蹴而就地生成“完美“的资源是十分罕见的。
这里不建议在发生错误的时候直接阻止用户继续开发，而是应该告诉用户到底错误发生在哪里，以及是什么错误，最好还得提供错误代码以及解决错误所需的信息。

#### 处理程序员的错误
要处理程序员的错误，需要使用十分多的测试样例来测试游戏引擎，保证不会因为程序员的个人失误导致出现bug。

#### 异常(抛出)

**错误返回码是一种简单且可靠的方式来传达和响应错误条件**。然而，错误返回码有其缺点。也许错误返回码最大的问题是，检测到错误的函数可能与能够处理该问题的函数完全无关。在最坏的情况下，一个在调用栈中 40 层深的函数可能会检测到一个只能由顶层游戏循环或 main()处理的问题。在这种情况下，调用栈上的每个函数都需要被编写，以便它可以将适当的错误码一直传递到顶层的错误处理函数。

一种解决这个问题的方法是抛出异常。异常处理是 C++的一个非常强大的特性。它允许检测到问题的函数在不了解可能处理该错误哪个函数的情况下，将错误信息传递给其他代码。当抛出异常时，关于错误的相关信息会被放入程序员选择的数据对象中，这个数据对象被称为异常对象。然后调用栈会自动展开，寻找一个用 try-catch 块包装了调用的函数。如果找到了 try-catch 块，异常对象会与所有可能的 catch 子句进行匹配，如果找到匹配项，则执行相应的 catch 代码块。在栈展开过程中，任何自动变量的析构函数会根据需要被调用。

将错误检测与错误处理分离的能力以这种方式实现确实很有吸引力，异常处理对于某些软件项目来说是一个极好的选择。然而，异常处理确实会给程序带来一些开销。包含 trycatch 块的任何函数的栈帧都必须增加额外的信息，以供栈展开过程使用。此外，如果你的程序中的任何函数（或你程序链接的库）使用异常处理，你的整个程序都必须使用异常处理——编译器无法知道当抛出异常时调用栈中哪些函数可能在你之上。

话说回来，可以通过“沙盒”化使用异常处理的库或多个库，以避免整个游戏引擎都必须启用异常处理。为此，你需要将有关库的 API 调用封装在异常处理启用的翻译单元中的函数中。每个函数都会在 try/catch 块中捕获所有可能的异常，并将它们转换为错误返回码。因此，任何与你的包装库链接的代码都可以安全地禁用异常处理。异常在某些方面不比 goto 语句好，因为异常抛出是一个隐式的过程，你很难去在一开始就发现错误到底是由于什么所引起的。

#### 断言
**断言是一行检查表达式的代码。如果表达式求值为真，则什么也不发生。但如果表达式求值为假，程序将停止，打印消息，如果可能的话，将调用调试器。**
> 请注意`__FILE__`和`__LINE__`的使用。这些编译器定义的宏神奇地包含了它们出现在其中的.cpp 文件名和行号。通过将它们传递到我们的消息显示函数中，我们可以打印出问题的确切位置。

在使用断言的时候，同时需要注意其性能开销，这玩意并不是什么省油的灯，如果对于某些断言来说，其性能成本过高，那么就不应该启用该宏，除非真的需要对其进行调试的时候。

##### 静态断言(static assertation)
静态断言就是为了解决上述性能问题的，使用静态断言可以保证在调试时不会计算静态断言表达式，而是在编译的时候开始计算。

### 数据、代码和内存布局
1. **数值表示**
**数字是在进行游戏开发的核心**
2. 数制
...
3. 有符号和无符号整数
	1. 定点表示法
	2. 浮点数表示法

---
#### C/C++ 程序的内存布局
用 C 或 C++ 编写的程序将其数据存储在内存中的多个不同位置。
##### 可执行映像
当一个C/C++程序被构建时，链接器会创建一个可执行的文件。大多数类UNIX操作系统都采用一种流行的可执行文件格式，称之为**可执行和链接格式**(ELF)
这些系统上的可执行文件因此具有 .elf 扩展名。Windows 的可执行格式与 ELF 格式类似；Windows 下的可执行文件具有 .exe 扩展名。**无论其格式如何，可执行文件始终包含程序在运行时将存在于内存中的部分映像。我说“部分”映像，因为程序通常在运行时分配内存，除了其可执行映像中定义的内存。**
可执行映像被划分为连续的块，称为**段或节**。每一个操作系统在内存布局上略有不同，同一个操作系统上的不同可执行文件在布局上也可能略有不同。但是大部分可执行文件都具有以下几个段：
- **文本段**：有时候称为*代码段*，该块包含程序中所有定义函数的可执行机器代码
- **数据段**：该段包含**所有初始化的全局和静态变量**。每个全局变量的内存布局与程序运行时完全一致，并且所有初始值都已填充。因此，当可执行文件加载到内存中时，初始化的全局和静态变量就已经准备好了
- **BSS段**：“BSS”是一个过时的名称，**代表“由符号开始的块”**。该段包含*所有未初始化的全局和程序定义的静态变量*。C 和 C++语言明确地将任何未初始化的全局或静态变量的初始值定义为零。但是，而不是在 BSS 段中存储一个可能非常大的零块，链接器只是存储一个计数值，以说明在段中需要多少个零字节来解释所有的未初始化的全局和静态变量。当可执行文件加载到内存中时，操作系统为 BSS 段预留了请求的字节数，并在调用程序的入口点（例如`main()`或`WinMain()`）之前将其填充为零。
- 只读数据段。有时称为 rodata 段，该段包含程序定义的任何只读（常量）全局数据。例如，所有浮点常量（例如，`const float kPi = 3.141592f;`）和所有使用`const`关键字声明的全局对象实例（例如，`const Foo gReadOnlyFoo;`）都位于此段中。请注意，整数常量（例如，`const int kMaxMonsters = 255;`）通常被编译器用作明文常量，这意味着它们被直接插入到机器代码的任何使用位置。这些常量占用文本段的存储空间，但它们不位于只读数据段中。

##### 程序栈
**当可执行程序加载到内存并运行时，操作系统会为程序栈保留一块内存区域**。每当调用一个函数时，连续的栈内存区域会被推入栈中——我们称这块内存为一个**栈帧**
栈帧存储三种类型的数据：
- 它**存储调用函数的返回地址**，以便在调用函数返回时继续执行调用函数。
- 栈帧中保存了**所有相关的 CPU 寄存器的内容**。这使得新函数可以自由地使用寄存器，而不用担心覆盖调用函数所需的数据。返回到调用函数时，寄存器的状态被恢复，以便调用函数可以继续执行。被调用函数的返回值（如果有的话）通常会留在特定的寄存器中，以便调用函数可以检索它，但其他寄存器会被恢复到原始值。
- 栈帧还包含**函数声明的所有局部变量**；这些变量也被称为***自动变量***。这使得每个不同的函数调用都能保持其每个局部变量的私有副本，即使函数调用自身进行递归。 *（实际上，某些局部变量实际上分配给了 CPU 寄存器而不是存储在栈帧中，但大多数情况下这些变量表现得好像它们是在函数的栈帧中分配的一样。）*
z

##### 类静态成员
