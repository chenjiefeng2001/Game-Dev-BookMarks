本篇文章是对于书籍*Game Engine Architecture*的具体解读
## 第一部分 基础
本书目标：
- 如何正确构建一个能够用在工业生产中的游戏引擎
- 游戏开发团队在现实世界中是如何进行组织和工作的
- 游戏引擎中有什么新的子系统以及采用何种设计模式
- 每个主要的子系统的典型需求
- 那些子系统与类型或者游戏无关，哪些又反过来与游戏类型有关
- 游戏引擎通常结束且游戏开始的地方

> ### 预备知识
> 在接下来往下看之前，请确保具有以下的几个预备知识：
> - 线性代数基础
> - 矩阵数学
> - 三角函数的计算
> - 基础代码知识(大部分是C++)

### 典型游戏团队的结构
对于一个典型的游戏团队，应该具有以下的几个职位：
1. 工程师
	工程师是构建程序的主力，没有工程师就没有游戏的程序
2. 艺术家
	用于往游戏程序中添加资产
3. 游戏设计师
	对游戏的关卡、地图等进行设计调控，以确保玩家能进入心流
4. 生产者
	生产者
5.  其他人员
	其他闲杂人员
6. 出版商和工作室
	用于发行游戏和对资金进行管理

### 一些相关定义
1. 游戏的定义
游戏的定义请参考其他的书籍，这里不做探讨。
 2. 游戏引擎的定义
可以说，数据驱动的架构正是游戏引擎与一款游戏而非引擎的软件之间的区别。具有一定的可复用性和

### 不同游戏类型的引擎差异
对于游戏引擎来说，不同的游戏使用的游戏引擎具有的子系统也不尽相同。以下列举对于每个游戏类型来说游戏引擎的侧重点：

1. 第一人称射击游戏(FPS):
	- 灵敏的**摄像头控制/瞄准机制**
	- 玩家的*虚拟手臂*，和武器的高保真动画
	-  各种**强大的**手持武器
	- 宽容的玩家角色**运动和碰撞模型**
	- 非玩家角色的**高保真动画和AI**
	- 小规模在线多人游戏功能以及无处不在的“死亡竞赛”游戏模式
> 当然，要让玩家沉浸在超现实的游戏世界中，需要的不仅仅是优化的高质量图形技术。角色动画、音频和音乐、刚体物理、游戏内过场动画以及众多其他技术，对于第一人称射击游戏来说都必须是尖端的。因此，这类游戏对技术的要求在业内堪称最严格、最广泛。
> 第一人称射击游戏所采用的渲染技术几乎总是经过高度优化，并根据特定类型的渲染环境进行精心调整。例如，室内“地下城探索”游戏通常采用二进制空间分区树或基于传送门的渲染系统。户外 FPS 游戏则使用其他类型的渲染优化，例如遮挡剔除，即对游戏世界进行离线分区，手动或自动指定每个源扇区中可见的目标扇区。
2. 平台游戏和其他第三人称游戏
> 第三人称角色扮演游戏与第一人称射击游戏有很多共同之处，但第三人称角色扮演游戏更注重主角的能力和移动方式。此外，第三人称角色扮演游戏要求玩家角色拥有高保真度的全身角色动画，这与典型的第一人称射击游戏对“悬浮手臂”动画的要求相对低一些。需要注意的是，几乎所有第一人称射击游戏都包含在线多人游戏组件，因此除了第一人称手臂动画外，还必须渲染玩家角色的全身动画。然而，这些第一人称射击游戏玩家角色的保真度通常无法与同类游戏中非玩家角色的保真度相比，也无法与第三人称游戏中玩家角色的保真度相比。
> 在平台游戏中，主角通常采用卡通风格，并非特别逼真或高分辨率。然而，第三人称射击游戏通常以高度逼真的人形玩家角色为特色。在这两种情况下，玩家角色通常都拥有非常丰富的动作和动画。
- 移动平台、梯子、绳索和棚架等有趣的**运动模式**
- 类似谜题的**环境元素**
- 第三人称“**跟随摄像机**”，其焦点始终*集中在玩家角色上*，其旋转通常由人类玩家通过右侧游戏手柄摇杆（在游戏机上）或鼠标（在 PC 上——请注意，虽然 PC 上有许多流行的第三人称射击游戏，但平台游戏类型几乎只存在于游戏机上）控制
- 一个**复杂的相机碰撞系统**，用于**确保视点永远不会“剪切”背景几何或动态前景物体**
### 格斗游戏
通常为双人游戏，在游玩时一般是在一个场地内进行互相攻击。
1. 在传统的格斗游戏上通常聚焦于：
	- 丰富的战斗动画
	- 准确的命中检测
	- 能够检测复杂按钮和操纵杆组合的用户输入系统
	- 人群背景板，但背景相对静止
2.  现代格斗游戏主要聚焦于：
	- 高清人物图形
	- 具有地下散射和汗液效果的逼真的皮肤着色器
	- 逼真的灯光和粒子效果
	- 高保真角色动画
	- 基于物理的角色布料和头发模拟
> 值得注意的是，一些格斗游戏，例如 Ninja Theory 的《天剑》和育碧蒙特利尔工作室的《荣耀战魂》，其背景设定在一个大规模的虚拟世界，而非一个封闭的竞技场中。事实上，许多人认为格斗游戏是一个独立的游戏类型，有时被称为“格斗游戏”。这类格斗游戏的技术要求可能更类似于第三人称射击游戏或策略游戏。

### 赛车游戏
赛车游戏主要专注于：
- 在渲染远处的背景元素时，会使用各种“技巧”，例如使用二维卡片来表示树木、丘陵和山脉
- 赛道通常被分解成相对简单的二维区域，称为“扇区”。这些数据结构用于优化渲染和可见性判断，辅助人工智能和非人为控制车辆的路径查找，以及解决许多其他技术问题
- 摄像机通常跟随车辆后方，以便第三人称视角，或者有时位于驾驶舱内的第一人称视角
- 当赛道涉及隧道和其他“狭窄”空间时，通常需要付出很大努力来确保摄像机不会与背景几何形状发生碰撞

### 策略游戏
*策略游戏玩家通常无法为了观察远距离而大幅改变视角。这种限制使得开发者能够在策略游戏的渲染引擎中运用各种优化*。该类型的老游戏采用**基于网格（基于单元）的世界构建**，并使用正交投影来大大简化渲染器。现代策略游戏有时会使用透视投影和真实的 3D 世界，但它们仍可能采用网格布局系统来确保单位和背景元素（例如建筑物）彼此正确对齐。
常见的关注点在于：
- 每个单元的分辨率相对较低，因此游戏可以同时在屏幕上支持大量单元
- 高度场地形通常是游戏设计和玩游戏的画布
- 除了部署自己的部队之外，玩家通常还可以在地形上建造新建筑
- 用户交互通常是通过单击和基于区域的单位选择，加上包含命令、设备、单位类型、建筑类型等的菜单或工具栏

### 大型多人在线游戏(MMORPG)
MMO 被定义为**支持大量同时玩家（从数千到数十万）的游戏**，通常所有玩家都在一个**非常庞大、持久的虚拟世界**中游戏.所有大型多人在线游戏的核心是一个非常强大的服务器集群。这些服务器维护着游戏世界的权威状态，管理用户登录和退出游戏，提供用户间聊天或 IP 语音（VoIP）服务等等。几乎所有的 MMOG 都需要用户支付某种形式的定期订阅费才能玩，并且它们可能还会在游戏世界内或游戏外提供微交易。因此，中央服务器最重要的角色可能是**处理账单和微交易**，这些*微交易*是游戏开发者主要的收入来源。

> 我们在这里应该指出，最近流行的游戏《绝地求生》（PUBG）推广了一个名为“大逃杀”的子类型。这种游戏模糊了普通多人射击游戏和大型多人在线游戏之间的界限，因为它们通常将大约 100 名玩家放在一个在线世界中相互对抗，采用基于生存的“最后一人站立”的玩法风格。

### 虚拟混合游戏
虚拟混合游戏通常为MR或者VR游戏，其主要关注：
- 立体渲染。VR 游戏需要为每只眼睛渲染场景两次。这使必须渲染的图形基元数量翻倍，尽管图形管道的其他方面，如可见性剔除，每帧只需执行一次，因为眼睛彼此靠得比较近。因此，与在分屏多人模式中渲染相同游戏相比，VR 游戏的渲染成本并不是那么高，但渲染每帧两次，从两个（略有）不同的虚拟摄像机进行渲染的原则是相同的
- **非常高的帧率**
- 导航问题



## 第二章 工具箱
这里提供一些工具来帮助搭建游戏引擎。
1. 版本控制
	常见的版本控制系统：
	- 源代码控制系统(SCCS)
	- 版本控制系统(RCS)
	- 并发版本系统(CVS)
	- Subversion
	- Git(**推荐**)

2. 编译器、链接器和集成开发环境
这部分略过，已经构建过一次项目

## 第三章 游戏软件工程基础
本章目标：
- 回顾有关游戏软件工程的基础知识

### C++回顾和最佳实践
C++是目前游戏业界的主要语言，因此本书主要关注C++，当然，其他语言也是十分重要的

#### 面向对象编程简要回顾
1. 类和对象
类是一个**属性（数据）和行为（代码）的集合**，这些属性和行为共同构成一个有用、有意义的整体。
> 类是一个规范，描述了类中各个实例（称为对象）的构造方式。
2. 封装
封装意味着黑盒子，即对象仅向外界展示有限的接口；对象内部状态和实现细节被隐藏起来。封装简化了类的使用者的生活，因为他们只需要理解类的有限接口，而不需要了解其复杂的实现细节。
3. 继承
继承**允许新类被定义为现有类的扩展**。新类修改或扩展了现有类的数据、接口和/或行为。
	1. 多重继承
	一些语言支持多重继承（MI），这意味着一个类可以有多个父类。**理论上MI可以非常优雅，但在实践中这种设计通常会导致非常的混乱**。
	2. 多态性
	*多态性是一种语言特性*，它允许通过单个公共接口来操作不同类型的对象集合。公共接口使得异构对象集合从使用该接口的代码的角度来看显得是同构的。、
	3. 聚合与组合
	组合是指**使用一组相互作用的对象来完成一项高级任务**。组合在类之间创建了一个“有-个”或“使用-个”的关系。
4. 设计模式
当同一种类型的问题反复出现，许多不同的程序员都采用非常相似的解决方案时，我们就说一个设计模式已经出现，以下是一些常见的设计模式：
- **单例模式**。这种模式确保一个特定的类只有一个实例(单例实例)，并提供一个全局访问点。
- **迭代器**。迭代器提供了一种高效的方式来访问集合中的各个元素，而无需暴露集合的底层结构实现。迭代器“知道”集合的实现细节，因此用户不必知道。
- 抽象工厂。抽象工厂提供了一种接口，用于创建一系列相关的或者依赖的类，而无需指定它们的具体类。
**情节工和RAII**
这是一种十分有用的设计模式示例，在RAII模式中，资源的获取和释放分别绑定到类的构造函数和析构函数中。*这可以防止程序员不小心忘记释放资源——你只需构造一个类的局部实例来获取资源，让它出作用域即可自动释放*
#### C++ 语言标准化
这里**略过**。


### 捕获和处理错误
在游戏引擎中，有几种方法可以捕获和处理错误的情况。作为一名游戏程序员，理解这些不同的机制
、它们的优缺点以及何时使用每种机制非常重要。

##### 错误类型
1. 用户错误
用户错误发生在程序**用户执行不正确操作时**，例如输入无效数据、尝试打开不存在的文件等
2. 程序员错误
	程序员错误是代码本身的错误的结果。尽管它可能是由用户的行为触发的，但尝试打开一个不存在的文件，程序员的本质错误在于，**如果程序员没有犯错误，这个问题本可以避免，而且用户有合理的期望，即程序应该优雅地处理这种情况**。

#### 处理开发者错误
对于游戏引擎来说，用户主要为游戏制作人，这些用户所引起的错误大概率为某种无效的资源所引起。
一方面，似乎有必要防止不良游戏资源停留过久，另一方面，游戏开发是一个混乱且迭代的过程，一蹴而就地生成“完美“的资源是十分罕见的。
这里不建议在发生错误的时候直接阻止用户继续开发，而是应该告诉用户到底错误发生在哪里，以及是什么错误，最好还得提供错误代码以及解决错误所需的信息。

#### 处理程序员的错误
要处理程序员的错误，需要使用十分多的测试样例来测试游戏引擎，保证不会因为程序员的个人失误导致出现bug。

#### 异常(抛出)

**错误返回码是一种简单且可靠的方式来传达和响应错误条件**。然而，错误返回码有其缺点。也许错误返回码最大的问题是，检测到错误的函数可能与能够处理该问题的函数完全无关。在最坏的情况下，一个在调用栈中 40 层深的函数可能会检测到一个只能由顶层游戏循环或 main()处理的问题。在这种情况下，调用栈上的每个函数都需要被编写，以便它可以将适当的错误码一直传递到顶层的错误处理函数。

一种解决这个问题的方法是抛出异常。异常处理是 C++的一个非常强大的特性。它允许检测到问题的函数在不了解可能处理该错误哪个函数的情况下，将错误信息传递给其他代码。当抛出异常时，关于错误的相关信息会被放入程序员选择的数据对象中，这个数据对象被称为异常对象。然后调用栈会自动展开，寻找一个用 try-catch 块包装了调用的函数。如果找到了 try-catch 块，异常对象会与所有可能的 catch 子句进行匹配，如果找到匹配项，则执行相应的 catch 代码块。在栈展开过程中，任何自动变量的析构函数会根据需要被调用。

将错误检测与错误处理分离的能力以这种方式实现确实很有吸引力，异常处理对于某些软件项目来说是一个极好的选择。然而，异常处理确实会给程序带来一些开销。包含 trycatch 块的任何函数的栈帧都必须增加额外的信息，以供栈展开过程使用。此外，如果你的程序中的任何函数（或你程序链接的库）使用异常处理，你的整个程序都必须使用异常处理——编译器无法知道当抛出异常时调用栈中哪些函数可能在你之上。

话说回来，可以通过“沙盒”化使用异常处理的库或多个库，以避免整个游戏引擎都必须启用异常处理。为此，你需要将有关库的 API 调用封装在异常处理启用的翻译单元中的函数中。每个函数都会在 try/catch 块中捕获所有可能的异常，并将它们转换为错误返回码。因此，任何与你的包装库链接的代码都可以安全地禁用异常处理。异常在某些方面不比 goto 语句好，因为异常抛出是一个隐式的过程，你很难去在一开始就发现错误到底是由于什么所引起的。

#### 断言
**断言是一行检查表达式的代码。如果表达式求值为真，则什么也不发生。但如果表达式求值为假，程序将停止，打印消息，如果可能的话，将调用调试器。**
> 请注意`__FILE__`和`__LINE__`的使用。这些编译器定义的宏神奇地包含了它们出现在其中的.cpp 文件名和行号。通过将它们传递到我们的消息显示函数中，我们可以打印出问题的确切位置。

在使用断言的时候，同时需要注意其性能开销，这玩意并不是什么省油的灯，如果对于某些断言来说，其性能成本过高，那么就不应该启用该宏，除非真的需要对其进行调试的时候。

##### 静态断言(static assertation)
静态断言就是为了解决上述性能问题的，使用静态断言可以保证在调试时不会计算静态断言表达式，而是在编译的时候开始计算。

### 数据、代码和内存布局
1. **数值表示**
**数字是在进行游戏开发的核心**
2. 数制
...
3. 有符号和无符号整数
	1. 定点表示法
	2. 浮点数表示法

---
#### C/C++ 程序的内存布局
用 C 或 C++ 编写的程序将其数据存储在内存中的多个不同位置。
##### 可执行映像
当一个C/C++程序被构建时，链接器会创建一个可执行的文件。大多数类UNIX操作系统都采用一种流行的可执行文件格式，称之为**可执行和链接格式**(ELF)
这些系统上的可执行文件因此具有 .elf 扩展名。Windows 的可执行格式与 ELF 格式类似；Windows 下的可执行文件具有 .exe 扩展名。**无论其格式如何，可执行文件始终包含程序在运行时将存在于内存中的部分映像。我说“部分”映像，因为程序通常在运行时分配内存，除了其可执行映像中定义的内存。**
可执行映像被划分为连续的块，称为**段或节**。每一个操作系统在内存布局上略有不同，同一个操作系统上的不同可执行文件在布局上也可能略有不同。但是大部分可执行文件都具有以下几个段：
- **文本段**：有时候称为*代码段*，该块包含程序中所有定义函数的可执行机器代码
- **数据段**：该段包含**所有初始化的全局和静态变量**。每个全局变量的内存布局与程序运行时完全一致，并且所有初始值都已填充。因此，当可执行文件加载到内存中时，初始化的全局和静态变量就已经准备好了
- **BSS段**：“BSS”是一个过时的名称，**代表“由符号开始的块”**。该段包含*所有未初始化的全局和程序定义的静态变量*。C 和 C++语言明确地将任何未初始化的全局或静态变量的初始值定义为零。但是，而不是在 BSS 段中存储一个可能非常大的零块，链接器只是存储一个计数值，以说明在段中需要多少个零字节来解释所有的未初始化的全局和静态变量。当可执行文件加载到内存中时，操作系统为 BSS 段预留了请求的字节数，并在调用程序的入口点（例如`main()`或`WinMain()`）之前将其填充为零。
- 只读数据段。有时称为 rodata 段，该段包含程序定义的任何只读（常量）全局数据。例如，所有浮点常量（例如，`const float kPi = 3.141592f;`）和所有使用`const`关键字声明的全局对象实例（例如，`const Foo gReadOnlyFoo;`）都位于此段中。请注意，整数常量（例如，`const int kMaxMonsters = 255;`）通常被编译器用作明文常量，这意味着它们被直接插入到机器代码的任何使用位置。这些常量占用文本段的存储空间，但它们不位于只读数据段中。

##### 程序栈
**当可执行程序加载到内存并运行时，操作系统会为程序栈保留一块内存区域**。每当调用一个函数时，连续的栈内存区域会被推入栈中——我们称这块内存为一个**栈帧**
栈帧存储三种类型的数据：
- 它**存储调用函数的返回地址**，以便在调用函数返回时继续执行调用函数。
- 栈帧中保存了**所有相关的 CPU 寄存器的内容**。这使得新函数可以自由地使用寄存器，而不用担心覆盖调用函数所需的数据。返回到调用函数时，寄存器的状态被恢复，以便调用函数可以继续执行。被调用函数的返回值（如果有的话）通常会留在特定的寄存器中，以便调用函数可以检索它，但其他寄存器会被恢复到原始值。
- 栈帧还包含**函数声明的所有局部变量**；这些变量也被称为***自动变量***。这使得每个不同的函数调用都能保持其每个局部变量的私有副本，即使函数调用自身进行递归。 *（实际上，某些局部变量实际上分配给了 CPU 寄存器而不是存储在栈帧中，但大多数情况下这些变量表现得好像它们是在函数的栈帧中分配的一样。）*
当一个包含自动变量的函数返回时，其栈帧会被丢弃，函数中的所有自动变量都应被视为不再存在。技术上，这些变量占用的内存仍然存在于被丢弃的栈帧中——但该内存很可能在另一个函数被调用时立即被覆盖。
##### 动态分配堆
上面已经介绍了全局变量和静态变量，以及局部变量。全局变量/静态变量在可执行文件的数据段和BSS段中分配，而局部变量在程序栈上分配
为了允许动态分配，操作系统为每个正在运行的进程维护一个内存块，进程可以通过调用`malloc()`或者在Windows下调用特定于操作系统的函数`HeapAlloc()`来分配内存、并在未来的某个特定时间通过调用`free()`返回内存以供调用。这里的内存块称为**堆内存**，或者**自由存储区**。*当我们动态分配内存时，我们有时会说这部分内存驻留在堆上*。
这里不做过多讨论，在第七章才会进行进一步讨论。

####  成员变量
类或结构声明**不会分配内存**。它*仅仅是数据的布局描述*——一个可以用来冲压该结构或类实例的模具。
一旦结构或类被声明，它就可以像基本数据类型一样以任何方式分配（定义）

##### 类静态成员
`static`关键字根据上下文有多种不同的含义：
- 在***文件作用域***中使用时，static 的意思是“**限制这个变量或函数的可见性，使其只能在这个 .cpp 文件内部可见。**”
- 当在***函数作用域***中使用时，static 的意思是“**这个变量是一个全局变量，而不是自动变量，但它只能在这个函数内部可见**。”
- 当在***结构体或类声明***中使用时，static 的意思是“**这个变量不是普通的成员变量，而是表现得就像一个全局变量**。”
> 当在类声明中使用 static 时，**它不会控制变量的可见性（就像在文件作用域中使用时那样）——相反，它区分了常规的每个实例成员变量和像全局变量一样的每个类变量**。类静态变量的可见性由类声明中使用的 `public:`、`protected:` 或 `private:`关键字决定。类静态变量会自动包含在它们声明的类或结构体的命名空间中。因此，每次在类或结构体外部使用该变量时，都必须使用类或结构体的名称来消除歧义

#### 内存中的对象布局
可以通过绘制内存布局图来简要地显示大致内存布局。[[内存布局图绘制方法]]

##### 对齐和打包
如果将小字节的数据和大字节的数据交错地放在一起，那么编译器会尝试将数据进行**内存对齐**——数据对象的对齐方式是指其在内存中的地址是否是其大小的倍数（通常大小是 2 的幂）：
- 1字节对齐的对象可以位于任何内存地址
- 2字节对齐的对象只能位于偶数地址（即最低有效四位的值为 0x0、0x2、0x4、0x8、0xA、0xC 或 0xE 的地址）
- 4 字节对齐的对象只能位于 4 的倍数地址（即最低有效四位的值为 0x0、0x4、0x8 或 0xC 的地址）
-  16 字节对齐的对象仅存在于地址为 16 的倍数的位置（即，地址的最低有效四位数是 0x0）
*常规情况下，文件一般为4k对齐*
当较小的数据类型（如 8 位 bool）与较大的类型（如 32 位整数或浮点数）在结构或类中交错时，编译器会在其中引入填充（空洞），以确保所有内容都正确对齐。*在声明您的数据结构时，考虑对齐和打包是一个好主意*。

##### C++类地内存布局
C++类在内存布局方面与 C 结构体略有不同，**这主要是由继承和多态函数引起的**
当类 B 继承自类 A 时，B 的数据成员会直接出现在 A 的内存之后，每个新的派生类只需将其数据成员添加到末尾，但对齐要求可能会在类之间引入填充。

---
## 第二部分 低级引擎系统
### 第六章 引擎支持系统
对于一个游戏引擎来说，需要一些低级的系统来管理一些日常但是至关重要的任务，
**本章重点**：
- 了解在游戏引擎中存在的最低级的支持系统
- 学会制作一个低级的支持系统

#### 子系统的启动和关闭
游戏引擎是由许多交互子系统组成的复杂软件。当引擎启动时，每个子系统都必须按照特定的顺序进行初始化，子系统之间的依赖关系决定了它们在游戏引擎启动时所采用的启动顺序。

#### C++ 静态初始化顺序(缺乏`thereof`)
由于大多数现代游戏引擎使用的编程语言为C++，我们应该简要的考虑是否可以利用C++的本地启动和关闭语义来控制启动和关闭我们引擎的子系统。在C++中，全局和静态对象在程序的入口点(通常为Main入口，若在windows下则为WinMain入口)被调用之前就构造了，然而这些构造函数的调用顺序是完全不可预测的。全局和静态类实例的析构函数在`Main()`或者`WinMain()`返回后被调用，并且它们的调用顺序也是完全不可以预测。
如果 C++ 能让我们对全局和静态类实例的构造和销毁顺序有更多的控制，我们就可以将我们的单例实例定义为全局变量，而无需动态内存分配。
```C++
class RenderManager
{
public:
RenderManager()
{
// start up the manager...
}
~RenderManager()
{
// shut down the manager...
}
// ...
};
// singleton instance
static RenderManager gRenderManager
```
##### 按需构建
虽然没办法按照上述的方式构建，但是我们可以使用一个“技巧”——**一个在函数内部声明的静态变量不会在 main() 被调用之前构建，而是在该函数第一次被调用时构建**，用这个方法可以很好的去控制全局单例的构建顺序
```c++
class RenderManager
{
public:
// Get the one and only instance.
static RenderManager& get()
{
// This function-static will be constructed on the
// first call to this function.
static RenderManager sSingleton;
return sSingleton;
}
RenderManager()
{
// Start up other managers we depend on, by
// calling their get() functions first...
VideoManager::get();
TextureManager::get();
// Now start up the render manager.
// ...
}
~RenderManager()
{
// Shut down the manager.
// ...
}
};
```
不幸的是，这仍然无法让我们控制销毁顺序。有可能在调用 `RenderManager`的析构函数之前，C++ 会销毁 `RenderManager` 依赖的一个管理器。此外，很难预测 `RenderManager` 单例的确切构建时间，因为它的构建将在第一次调用 `RenderManager::get()` 时发生——而谁又知道那会是什么时候呢？此外，使用该类的程序员可能没有预料到一个看似无害的 `get()` 函数会执行昂贵的操作，比如分配和初始化一个重量级的单例。这是一种不可预测且危险的设计。因此，我们被促使采用一种更直接的方法，以获得更大的控制权。

#### 一种简单有效的方法
假设我们想要坚持使用单例管理器来管理我们的子系统。在这种情况下，最简单的“蛮力”方法是为每个单例管理器类定义显式的启动和关闭函数。(*实际上我们应该让构造函数和析构函数什么也不做*)
当然，除了上述的蛮力解决之外，还有更加“优雅”的方法去解决：**例如使用管理器将自己注册到一个全局优先的队列中，然后遍历整个队列以达到按照顺序启动**。当然有需要甚至可以编写有关的计算代码让其按照需要来分别启动队列中的子系统。
当然，相较于采用队列计算的方式来启动子系统，蛮力实现具有以下的优势：
- 简单且易于实现
- 代码非常明确，可以一眼从代码看出启动顺序。
- 在调试和维护方面十分方便
当然，这也有缺点——在关闭的方面，可能会略微不严格相反的顺序进行关闭

> 此外，尽可能避免动态内存分配，因此许多单例都是静态分配的对象（例如，g_fileSystem、g_languageMgr 等）。它并不总是很漂亮，但能完成任务。

### 内存管理
**本章重点：**
- 学习如何优化我们的代码的内存利用率
内存管理是游戏引擎一个很重要的课题，任何软件的性能不仅仅取决于它所采用的算法，或这些算法的编码效率，还取决于程序如何利用内存。
内存一共有两种方式来直接影响性能：
- 通过`malloc()` 或 C++的全局 `new` 操作符进行**动态内存分配**是一个非常慢的操作。***我们可以通过完全避免动态分配，或使用自定义内存分配器来大大降低分配成本，从而提高代码的性能。***
- 在现代 CPU 上，*软件的性能通常由其内存访问模式决定*。正如我们将看到的，***位于内存小、连续块中的数据可以被 CPU 比分散在广泛内存地址中的相同数据更有效地操作***。即使是最有效的算法，如果编写得再小心，如果其操作的数据在内存中排列不高效，也可能会变得不堪重负。
#### 优化动态内存分配
通过 `malloc()` 和 `free()` 或 C++ 的全局 `new` 和 `delete` 运算符进行动态内存分配——也称为**堆分配**——通常非常慢。高成本可归因于两个主要因素。*首先，堆分配器是一个通用设施，因此必须编写以处理任何分配大小，从 1 字节到 1 吉字节。这需要大量的管理开销，使得 malloc() 和 free() 函数本质上很慢。*
其次在大多数操作系统中，对 malloc() 或 free() 的调用必须首先从用户模式上下文切换到内核模式，处理请求，然后上下文切换回程序。这些上下文切换可能非常昂贵。游戏开发中通常遵循的一条经验法则是：