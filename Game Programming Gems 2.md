本书主要是游戏有关的技术的论文集合，可以挑着看，没必要全部看完

## 1 Optimization for C++ Games 
> **Author:** Andrew Kirmse, LucasArts Entertainments

> Contact: ark@alum.mit.edu

这个技巧描述了你可以用来加速游戏的技术。它假设你已经确信使用 C++的好处，并且熟悉优化的基本原则（这些可以在“进一步探索”中找到）。值得重复的一个总原则是***分析（profiling）的绝对重要性***。在没有分析的情况下，程序员往往会犯两种类型的错误。
- 首先，他们优化了错误的代码。程**序的大部分不是性能关键，所以花时间加速它们是浪费的**。*关于哪个代码是性能关键的直觉是不可信的——只有通过直接测量才能确定*
- 其次，程序员有时会做出“优化”实际上会减慢代码速度。**这个问题在 C++中尤其突出，因为一句看似简单的代码实际上可能会生成大量的机器代码**。 检查你的编译器输出，并经常进行性能分析。
### 对象的构造和析构
这是一个核心概念，同时是编译器在后台生成机器码的主要部分。对于设计不良的程序来说，其在这个阶段会花费大量的时间来调用析构函数，以及构建临时对象。下面几个常识可以有效地让你在面对对象密集型的代码时能够保证代码运行速度接近于C:

- 延迟对象的构造，直到它们需要时再进行
**最快的代码就是那永远不执行的代码**
```C++
void Function(int arg)
{
	Object obj;
	if(arg *=0)
		return;
		...
}
```
即使 arg 为零，我们也要支付调用 Object 的构造函数和析构函数的成本。如果 arg 经常为零，尤其是如果 Object 本身分配内存，这种浪费可能会迅速累积。
解决方案是将 **obj 的声明移到 //check 之后**。
> 要注意在循环中声明非平凡的对象。如果你延迟对象的构造直到它在循环中需要时，你将支付每次迭代时对象构造和销毁的成本。**最好在循环之前声明对象，并且只支付这些成本一次**。*如果一个函数在内部循环中被调用，并且该函数在栈上创建一个对象，你可以选择在循环外部创建该对象，并将其作为引用传递给函数*。

- 使用初始化列表
考虑以下类：
```C++
class Vehicle
{
	public: 
		Vehicle(const std::string &name)//最好不要这么做
{
	mName=name;
	
}
	private:
	std::string mName;
	
};
```
因为成员变量在构造函数体被调用之前就已经被构造了，因此这段代码会调用`string mName`的构造函数，然后调用赋值运算符来复制对象的名字。但是十分糟糕的是，使用`string`默认构造函数
很可能会分配内存——实际上，分配的内存可能比存储在`Vehicle`构造函数中实际变量名所需的内存还要多。
> 此外，如果提供更多信息（在这个例子中是实际要存储的字符串），非默认的 string 构造函数通常可以更高效，编译器甚至可能优化掉空的 Vehicle 构造函数调用：

这里是优化后的版本代码：
```C++
class Vehicle{
	public: 
		Vehicle(const std::string &name) :mName(name)
		{}
	private:
	std::string mName;
};
```
- 建议使用前置自增而不是后置自增
写 x = y++ 的问题在于，*自增函数必须先复制 y 的原始值，然后自增 y，并返回原始值*。因此，后置自增涉及创建临时对象，而前置自增则不涉及。对于整数，没有额外的开销，但对于用户定义的类型，这是浪费。只要有可能，你应该使用前置自增。在 for 循环迭代器中，你几乎总是有这个选择。
- 避免使用返回值类型的运算符
在C++中编写向量加法的标准方法为：
```C++
Vector operator+ (const Vector &v1,const Vector &v2)
```
此运算符必须返回一个新的 Vector 对象，并且它必须通过值返回。虽然这允许像 v = v1 + z>2 这样有用且可读的表达式，但临时构建和 Vector 复制成本通常太高，对于像向量加法这样经常调用的操作来说。有时可以安排代码，以便编译器能够优化掉临时对象(这称为"返回值优化")，但是在一般情况下，最好忍痛放弃，编写稍微”丑陋“但是通常更快的代码：
```C++
void Vector::Add(const Vector &v1, const Vector &v2)
```
> 注意，***perator+=不受同样问题的困扰，因为它在原地修改第一个参数，并且不需要返回临时对象。因此，在可能的情况下，你应该使用+=运算符而不是+***

- 使用轻量级的构造函数
对于前面的Vector类的构造函数，不应该对其元素初始化为零应该在真正需要初始化的地方再进行初始化。
一个好的编译器可能会消除一些额外的代码，但为什么要冒险呢？作为一个一般规则，您希望对象构造函数初始化它的每个成员变量，因为未初始化的数据会导致微妙的问题。然而，对于经常作为临时实例的小类，您应该准备好为了性能而妥协这个规则。在许多游戏中，候选者是 Vector 和 Matrix 类。这些类应该提供方法（或替代构造函数）来将它们设置为零和单位，*但默认构造函数应该是空的*。
作为这一原则的推论，你应该为类提供额外的构造函数，如果我们的第二个示例中的Vehicle类是这样写的：
```C++
clasws Vehicle{
public:
Vehicle(){
}
void SetName(const std::string &name)
{
mName=name;
}
private:
	std::string mName;
};
```
我们将承担构造 mName 的成本，然后通过 `SetName()`再次设置它
- 预分配并缓存对象
一个游戏通常会有一些频繁分配和释放的类。在C的游戏中，通常会预先分配一个大的数组，并且在需要的时候使用它们。通过一点规划，你可以在C++中做同样的事情。***其思想是，不要不断地构造和销毁对象，而是请求新的对象并将旧的对象返回到缓存中。缓存可以作为模板实现，这样它就可以适用于任何类，前提是该类有一个默认构造函数。示例缓存类模板的代码在随附的 CD 上。***
你可以选择*按需分配对象来填充缓存，或者预先分配所有对象*。如果此外你还对对象维护栈规范（这意味着在你删除对象 X 之前，你首先删除所有在 X 之后分配的对象），你可以在连续的内存块中分配缓存。
C++应用程序通常需要比 C 应用程序更关注内存管理的细节。在 C 中，所有分配都是显式的，通过 mallocQ 和 freeQ 进行，*而 C++可以在构造临时对象和成员变量时隐式分配内存*。大多数 C++游戏（就像大多数 C 游戏一样）将需要自己的内存管理器
由于 C++游戏可能会执行许多分配，因此必须特别小心地防止堆碎片化。一个选项是采取传统方法之一：
***要么在游戏启动后不分配任何内存，要么维护一个大的连续内存块，该内存块定期释放***
1. 重载全局的`new`和`delete`运算符。使用自定义的运算符来实现来将游戏最常见的分配从`mallocQ`转移到预分配的内存块中
2. 为了跟踪哪些块是空闲的，通过将每个空闲块指向下一个空闲块来维护一个空闲列表。在分配时，从列表中移除前面的块，在释放时，将释放的块添加到列表的前面。

#### 虚函数
虚函数常常被认为是消耗性能的神秘特性，因为从概念上来讲，为了再一个对象上生成一个虚函数调用，那么编译器会访问该对象的虚函数表，并获取指向该成员函数的指针，设置调用然后跳转到该成员函数的地址。
这需要与 C 语言中的函数调用进行比较，在 C 语言中，*编译器设置调用并跳转到固定地址。虚函数调用的额外开销是到虚函数表的间接引用；由于调用地址事先未知，还可能存在处理器指令缓存未命中的惩罚。*

解决方法：**在性能关键区域避免这些调用**
```C++
class BaseClass
{
	public:
	virtual char *GetPointer()=0;
};
class Class"! : public BaseClass
{ 
	virtual char *GetPointer();
};
class Class2 : public BaseClass
{ 
	virtual char *GetPointer();
}|
void Function(BaseClass *pObj)
{ 
	char *ptr = pObj->GetPointer();
}
```
在上述函数中，如果FunctionQ对于性能至关重要，则需要将`BaeseClass::GetPointer`的调用从虚函数改为内联函数。****一种方法是向`BaseClass`添加一个新的受保护数据成员，并在每个类中设置该类数据成员***:
```C++
class BaseClass 
{
	public:
		inline char *GetPointerFast(){
			return mPointer;
		}
		protected:
			inline void SetPointer(char *pData)
			{
			mpData=pData;
			}
			private:
				char *mpData;
};
//类 class1 和类 class2 在成员函数中根据需要调用 SetPointer 
void Function(BaseClass *pObj)
{
	char *ptr =pObj-> GetPointerFast();
}
```
如果 `Classl` 和 `Class2` 只有细微的差别，将它们合并为一个类，通过一个标志在运行时决定类的行为方式，可能是一个更激进的措施。*这样做的改变（以及删除纯虚基类 BaseClass）可以使上一个示例中的 GetPointer 函数再次内联。这种转变远非优雅，但在小缓存的机器上的内层循环中，为了消除虚函数调用，你愿意做更糟糕的事情*。
> 尽管每个新的虚函数只增加了一个指针的大小到每个类的表中（通常是一个可以忽略的成本），但在类中的虚函数 yzrtf 需要在每个对象的基础上指向虚函数表。这意味着在小且经常使用的类中，你根本不希望有任何虚函数，因为这额外的开销是不可接受的。由于继承通常需要使用一个或多个虚函数（至少需要一个虚析构函数），对于小且频繁使用的对象，你也不想有任何层次结构。

#### 代码尺寸
编译器在生成 C++代码方面有点声名狼藉，因为它们生成的代码往往臃肿。由于内存有限，而且小就是快，因此重要的是尽可能使可执行文件保持小巧。**首先要做的是让编译器站在你这边。如果你的编译器在可执行文件中存储调试信息，请禁用调试信息的生成**。

> 注意：Microsoft Visual C++将调试信息存储在可执行文件之外，因此这可能不是必需的。

异常处理会生成额外代码；尽可能消除生成异常的代码。确保链接器配置为删除未使用的函数和类。启用编译器最高级别的优化，并尝试将其设置为优化大小而不是速度——有时这实际上会产生更快的代码，因为更好的指令缓存一致性。除调试打印语句中所有浪费空间的字符串，并让编译器将重复的常量字符串合并为单个实例。

**内联通常是导致可疑大函数的罪魁祸首**。*编译器可以自由地尊重或忽略你的内联关键字，而且它们可能会在不告诉你的情况下内联函数*。这是另一个保持你的构造函数轻量的原因，这样堆栈上的对象就不会生成大量的内联代码。另外也要小心重载运算符；像 `ml = m2 * m3` 这样的简单表达式可能会生成大量的内联代码。
> 如果 m2 和 m3 是矩阵，请了解您的编译器设置以进行函数内联。

启用运行时类型信息(`RTTI`)需要编译器为（几乎）程序中的每个类生成一些静态信息。通常启用 RTTI 是为了让代码能够调用 `dynamic_cast` 并确定对象的类型。考虑完全避免 `RTTI` 和 `dynamic_cast`，以节省空间（此外，`dynamic_cast` 在某些实现中非常昂贵）。相反，当你确实需要根据类型有不同的行为时，添加一个表现不同的虚函数。这无论如何都是更好的面向对象设计。（注意，这不适用于 `static_cast`，它和 C 风格的强制转换在性能上一样。）

#### 标准模板库
STL是一组用于实现常见的数据结构和算法的模板，如果动态数组、集合和映射。使用STL可以节省原本用于自己编写和调试这些容器所花费的大量时间。*然而，如果想要获得最大的代码效率，那么需要了解STL的具体实现细节*
为了允许最大范围的实现，***STL 标准在内存分配方面保持沉默。STL 容器上的每个操作都有一定的性能保证***
需要注意的是如果你使用了STL，那么***容器内存的使用是没办法得到保证的***
如果你只想存储一堆对象。通常你希望每个对象只在列表中出现一次，这样你就不用担心如果对象已经在集合中，还会不小心将其插入。STL集合会忽略重复项，插入、删除和查找的时间复杂度都是`O(log n)` ——虽然大多数操作集合都是`O(log n)`，这意味着对该算法忽略了前面的常数`C`。管集合的内存使用取决于实现，但许多实现基于红黑树，树中的每个节点存储集合的一个元素。通常的做法是*每次插入元素时分配一个树节点，每次删除元素时释放一个树节点。根据你插入和删除元素的频率，内存分配器花费的时间可能会超过使用集合所获得的任何算法节省*
一种替代方案使用 STL vector 来存储元素。vector 保证在集合末尾具有摊销常数时间的插入。这在实践中意味着 vector 通常只在偶尔重新分配内存。
从集合中删除的时间复杂度是 `O(log n)`，这看起来很快，但考虑到它可能还涉及一个` free()`调用。从向量中删除的时间复杂度是 O(n)，因为从删除元素到向量的末尾的所有元素都必须被复制到上一个位置。然而，如果向量的元素只是指针，所有的复制都可以在一个 `memcpyO` 调用中完成，这通常非常快。
> 这就是为什么通常最好在 STL 集合中存储对象指针而不是对象本身的原因。如果你直接存储对象，在删除等操作期间会调用许多额外的构造函数。

如果你仍然不认为集合和映射通常比它们更有用，请考虑迭代一个集合的成本，特别是：
```C++
for (Collection::iterator it = collection.begin();
	it != collection.end(); ++it)
```

> 如果上述的集合是一个向量，那么 ++it 是一个指针增量——一个机器指令。但当集合是一个集合或映射时，++it 涉及遍历到红黑树的下一个节点，这是一个相对复杂的操作，也更有可能导致缓存未命中，因为树节点可能分散在内存的各个地方。
> 如果你在集合中存储了大量的项目，并且进行了很多成员查询，那么集合的 O(log n) 性能很可能值得内存成本。类似地，如果你只是不经常使用这个集合，那么性能差异可能并不重要。你应该进行性能测量来确定什么值的 n 使集合更快。你可能惊讶地发现向量在游戏通常使用的所有值上都优于集合。

然而，关于 STL 内存使用这并非最终定论。**重要的是要知道当调用 clear()方法时，一个集合是否真的会释放其内存。如果不是，可能会导致内存碎片化**。
如何解决从空向量启动后重新开始时clear()不能完全释放内存导致内存碎片化的问题：
> 首先，你可以在创建向量时调用 reserve()，预留足够的空间以容纳你将需要的最大元素数量。如果这不可行，你可以通过以下方式显式地强制向量释放其内存：
> ```C++
> vector v; // ...元素被插入到 v 中 
> vector().swap(v);
> ```

集合、列表和映射通常不会出现这个问题，因为它们会单独分配和释放每个元素。

#### 高级特性
**并非所有语言都具备某个特性那么意味着你必须使用它**。看似简单的特性可能会有非常糟糕的性能，而其他看似复杂的特性实际上可能性能很好。C++ 最黑暗的角落高度依赖于编译器——在使用它们之前，确保你知道其代价。
***C++ 字符串是一个听起来很好但在性能重要时应该避免的特性***

对于下述代码：
```C++
void Function(const std::string &str)
{
//...
}
Function("Hello")
```
>对 FunctionQ 的调用会为字符串调用一个构造函数，给定一个 `const char *`。在一个商业实现中，这个构造函数执行了 `mallocQ`、`strlenQ` 和 `memcpyO`，而析构函数立即执行了一些非平凡的工作（因为这种实现中的字符串是引用计数的），然后是` freeQ`。分配的内存基本上是浪费的，因为字符串 `"hello"` 已经在程序的数据段中；我们实际上在内存中重复了它。如果 `FunctionQ `被声明为接受一个 `const char *`，调用将没有任何开销。


模板是效率相反的极端例子。根据语言标准，编译器在模板用特定类型实例化时生成代码。理论上听起来，一个模板声明会导致大量几乎相同的代码。如果你有一个 Class1 指针的向量和一个 Class2 指针的向量，你会在可执行文件中最终得到两个 vector 的副本。

对于大多数编译器来说，现实情况通常更好。首先，只有那些实际被调用的模板成员函数才会为其生成代码。其次，如果正确行为得以保持，编译器被允许只生成一份代码。通常你会发现，在之前给出的向量示例中，只会生成一份代码（可能是针对 vector 的）。给定一个优秀的编译器，模板为你提供了通用编程的所有便利，同时保持了高性能。

C++ 的一些特性，如初始化列表和前置自增，通常会提高性能，而其他一些特性，如重载运算符和 RTTI，看起来同样无害，但会带来严重的性能损失。STL 集合说明了盲目信任函数的文档算法运行时间可能会让你误入歧途。避免语言和库中潜在的低效特性，并花费一些时间熟悉你的分析器和编译器中的选项。你会很快学会为速度设计并找出游戏中的性能问题。

### Inline Functions Versus Macros
> **Author**:Peter Dalton, Evans & Sutherland
> Contact: pdalton@xmission.com

本篇主要讨论了
#### 内联函数的优点
1. 使用内联函数可以有效地避免宏定义的一些固有缺点：
```C++
#define max(a,b)((a)>(b)?(a):(b))
```
若调用上述的宏，并且设置x=5,j=3，那么宏的返回值则是7而不是预期的6——这里是由于宏的最常见的副作用即传递的参数会被多次执行求值。
要避免此副作用，最好使用内联函数来实现：
```C++
inline int max(int a, int b)
{
return (a>b ? a : b);
}
```

**通过使用内联方法，我们保证所有参数只被求值一次，因为它们必须遵循所有在普通函数上强制执行的协议和类型安全。**

 宏的另一个缺点是**运算符优先级**，例如以下的宏：
 ```C++
 #define square(x) (x*x)
```
如果使用`2+1`调用该宏，那么会返回的值是5而不是预期的9，原因在于乘法运算符的优先级显著高于加法运算符。

最令人恼火的部分是多语句宏，以及确保宏中的所有语句都能够正确的执行。

以下述的宏进行讨论：
```C++
#define clamp(a) \
	if (a >1.0) a=1.0; \
	if  (a<0.0) a=0.0; \
```
在以下的代码中循环使用宏：
```C++
for (int ii=0;ii<N;ii++)
	{
	clamp(numbersToBeClamped[ii])}
```
如果它们小于零，则不会对数字进行限制。只有当 for 循环终止时，当`ii == N` 时，表达式 `if(numbersToBeClamped[ii] <0.0) `需要被评估。这也是一个很严重的问题，因为索引变量 `ii` 现在是超出范围，很容易导致内存边界违规，从而崩溃程序。虽然用内联函数替换宏以执行相同功能并非唯一解决方案，但它是最干净的。
于宏的这些固有缺点，让我们来看看内联函数的优点：
- 内联函数**遵循对普通函数强制执行的类型安全协议**。这确保了不会将意外或无效的参数作为参数传递
- ***内联函数的指定方式与其他任何函数相同，只是在函数声明中添加了 inline 关键字***。
- 作为内联函数参数传递的表达式在进入函数体之前被评估；因此，*表达式只被评估一次*。如前所示，传递给宏的表达式可能会被多次评估，并可能导致不安全和意外的副作用。
- **使用 Microsoft 的 Visual C++ 等调试器可以调试内联函数**。而宏则不行，因为宏是在解析器接管并创建程序的符号表之前展开的。
- **内联函数无疑增加了过程的可读性和可维护性，因为它们使用与普通函数调用相同的语法，但不会意外地修改参数**。
内联函数还优于普通函数，通过消除函数调用的开销。这包括栈帧设置、参数传递、栈帧恢复和返回序列等任务。除了这些主要优势外，内联函数还为编译器提供了执行改进代码的优化能力。
**通过将内联函数替换为代码，插入的代码可以受到额外的优化，这是以前不可能的，因为大多数编译器不会执行跨过程优化**
允许编译器**执行全局优化**，如公共子表达式消除和循环不变量消除，可以显著提高速度和大小
**联函数的唯一限制，在宏中不存在的是参数类型的限制。宏允许任何可能的类型作为参数；然而，内联函数只允许指定的参数类型以强制类型安全**，要解决这个问题我们可以使用内联模板函数来克服这个限制。

##### 何时使用内联函数
当然，内联函数是一个十分优秀的工具，但是用不好依旧会让你的代码变得十分的糟糕。至于为什么不能每个函数都使用内联函数，因为这样会导致代码过分地膨胀，带来的负作用已经远超过其带来的速度变快的好处。
在评估程序性能时，需要权衡两个因素：执行速度和实际代码大小。增加代码大小会占用更多内存，而内存是宝贵的资源，同时也会降低执行速度。随着程序内存需求的增加，缓存未命中和页面错误的概率也会增加。虽然缓存未命中会导致轻微的延迟，但页面错误总会导致较大的延迟，因为虚拟内存位置不在物理内存中，必须从磁盘获取。

所以如何使用内联函数，以及何时使用它？
以下有一些内联函数工具良好工作的指南：
- 小方法
- 返回对象状态信息的方法
- 小函数，通常三行或者更小
- 反复调用的简短函数

**花费在调用/返回序列中时间比例较长的函数将不太受益于内联。然而，正确使用内联可以大大提高过程性能。**
##### 何时使用宏？
尽管宏存在一些问题，但在某些情况下它们非常有价值。
宏可用于创建小型伪语言，这些语言可以非常强大。一组宏可以提供创建状态机的框架，同时非常易于调试且健壮。
**避免与宏相关问题的关键在于，首先理解问题，其次了解替代实现方案**

##### Microsoft 特有功能
除了标准的内联关键字外，微软的Visual C++编译器还提供了两个额外的关键字支持。内联关键字指示编译器进行成本效益分析，并且只有当它证明是有益的时候才内联该函数。
forceinline 关键字指示编译器始终内联该函数。尽管使用了这些关键字，但在某些情况下编译器可能无法遵守，正如微软的文档MSDN中所述
