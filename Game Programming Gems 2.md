本书主要是游戏有关的技术的论文集合，可以挑着看，没必要全部看完

## 1 Optimization for C++ Games 
> **Author:** Andrew Kirmse, LucasArts Entertainments
>
> Contact: ark@alum.mit.edu

这个技巧描述了你可以用来加速游戏的技术。它假设你已经确信使用 C++的好处，并且熟悉优化的基本原则（这些可以在“进一步探索”中找到）。值得重复的一个总原则是***分析（profiling）的绝对重要性***。在没有分析的情况下，程序员往往会犯两种类型的错误。
- 首先，他们优化了错误的代码。程**序的大部分不是性能关键，所以花时间加速它们是浪费的**。*关于哪个代码是性能关键的直觉是不可信的——只有通过直接测量才能确定*
- 其次，程序员有时会做出“优化”实际上会减慢代码速度。**这个问题在 C++中尤其突出，因为一句看似简单的代码实际上可能会生成大量的机器代码**。 检查你的编译器输出，并经常进行性能分析。
### 对象的构造和析构
这是一个核心概念，同时是编译器在后台生成机器码的主要部分。对于设计不良的程序来说，其在这个阶段会花费大量的时间来调用析构函数，以及构建临时对象。下面几个常识可以有效地让你在面对对象密集型的代码时能够保证代码运行速度接近于C:

- 延迟对象的构造，直到它们需要时再进行
**最快的代码就是那永远不执行的代码**
```C++
void Function(int arg)
{
	Object obj;
	if(arg *=0)
		return;
		...
}
```
即使 arg 为零，我们也要支付调用 Object 的构造函数和析构函数的成本。如果 arg 经常为零，尤其是如果 Object 本身分配内存，这种浪费可能会迅速累积。
解决方案是将 **obj 的声明移到 //check 之后**。
> 要注意在循环中声明非平凡的对象。如果你延迟对象的构造直到它在循环中需要时，你将支付每次迭代时对象构造和销毁的成本。**最好在循环之前声明对象，并且只支付这些成本一次**。*如果一个函数在内部循环中被调用，并且该函数在栈上创建一个对象，你可以选择在循环外部创建该对象，并将其作为引用传递给函数*。

- 使用初始化列表
考虑以下类：
```C++
class Vehicle
{
	public: 
		Vehicle(const std::string &name)//最好不要这么做
{
	mName=name;
	
}
	private:
	std::string mName;
	
};
```
因为成员变量在构造函数体被调用之前就已经被构造了，因此这段代码会调用`string mName`的构造函数，然后调用赋值运算符来复制对象的名字。但是十分糟糕的是，使用`string`默认构造函数
很可能会分配内存——实际上，分配的内存可能比存储在`Vehicle`构造函数中实际变量名所需的内存还要多。
> 此外，如果提供更多信息（在这个例子中是实际要存储的字符串），非默认的 string 构造函数通常可以更高效，编译器甚至可能优化掉空的 Vehicle 构造函数调用：

这里是优化后的版本代码：
```C++
class Vehicle{
	public: 
		Vehicle(const std::string &name) :mName(name)
		{}
	private:
	std::string mName;
};
```
- 建议使用前置自增而不是后置自增
写 x = y++ 的问题在于，*自增函数必须先复制 y 的原始值，然后自增 y，并返回原始值*。因此，后置自增涉及创建临时对象，而前置自增则不涉及。对于整数，没有额外的开销，但对于用户定义的类型，这是浪费。只要有可能，你应该使用前置自增。在 for 循环迭代器中，你几乎总是有这个选择。
- 避免使用返回值类型的运算符
在C++中编写向量加法的标准方法为：
```C++
Vector operator+ (const Vector &v1,const Vector &v2)
```
此运算符必须返回一个新的 Vector 对象，并且它必须通过值返回。虽然这允许像 v = v1 + z>2 这样有用且可读的表达式，但临时构建和 Vector 复制成本通常太高，对于像向量加法这样经常调用的操作来说。有时可以安排代码，以便编译器能够优化掉临时对象(这称为"返回值优化")，但是在一般情况下，最好忍痛放弃，编写稍微”丑陋“但是通常更快的代码：
```C++
void Vector::Add(const Vector &v1, const Vector &v2)
```
> 注意，***perator+=不受同样问题的困扰，因为它在原地修改第一个参数，并且不需要返回临时对象。因此，在可能的情况下，你应该使用+=运算符而不是+***

- 使用轻量级的构造函数
对于前面的Vector类的构造函数，不应该对其元素初始化为零应该在真正需要初始化的地方再进行初始化。
一个好的编译器可能会消除一些额外的代码，但为什么要冒险呢？作为一个一般规则，您希望对象构造函数初始化它的每个成员变量，因为未初始化的数据会导致微妙的问题。然而，对于经常作为临时实例的小类，您应该准备好为了性能而妥协这个规则。在许多游戏中，候选者是 Vector 和 Matrix 类。这些类应该提供方法（或替代构造函数）来将它们设置为零和单位，*但默认构造函数应该是空的*。
作为这一原则的推论，你应该为类提供额外的构造函数，如果我们的第二个示例中的Vehicle类是这样写的：
```C++
clasws Vehicle{
public:
Vehicle(){
}
void SetName(const std::string &name)
{
mName=name;
}
private:
	std::string mName;
};
```
我们将承担构造 mName 的成本，然后通过 `SetName()`再次设置它
- 预分配并缓存对象
一个游戏通常会有一些频繁分配和释放的类。在C的游戏中，通常会预先分配一个大的数组，并且在需要的时候使用它们。通过一点规划，你可以在C++中做同样的事情。***其思想是，不要不断地构造和销毁对象，而是请求新的对象并将旧的对象返回到缓存中。缓存可以作为模板实现，这样它就可以适用于任何类，前提是该类有一个默认构造函数。示例缓存类模板的代码在随附的 CD 上。***
你可以选择*按需分配对象来填充缓存，或者预先分配所有对象*。如果此外你还对对象维护栈规范（这意味着在你删除对象 X 之前，你首先删除所有在 X 之后分配的对象），你可以在连续的内存块中分配缓存。
C++应用程序通常需要比 C 应用程序更关注内存管理的细节。在 C 中，所有分配都是显式的，通过 mallocQ 和 freeQ 进行，*而 C++可以在构造临时对象和成员变量时隐式分配内存*。大多数 C++游戏（就像大多数 C 游戏一样）将需要自己的内存管理器
由于 C++游戏可能会执行许多分配，因此必须特别小心地防止堆碎片化。一个选项是采取传统方法之一：
***要么在游戏启动后不分配任何内存，要么维护一个大的连续内存块，该内存块定期释放***
1. 重载全局的`new`和`delete`运算符。使用自定义的运算符来实现来将游戏最常见的分配从`mallocQ`转移到预分配的内存块中
2. 为了跟踪哪些块是空闲的，通过将每个空闲块指向下一个空闲块来维护一个空闲列表。在分配时，从列表中移除前面的块，在释放时，将释放的块添加到列表的前面。

### 虚函数
虚函数常常被认为是消耗性能的神秘特性，因为从概念上来讲，为了再一个对象上生成一个虚函数调用，那么编译器会访问该对象的虚函数表，并获取指向该成员函数的指针，设置调用然后跳转到该成员函数的地址。
这需要与 C 语言中的函数调用进行比较，在 C 语言中，*编译器设置调用并跳转到固定地址。虚函数调用的额外开销是到虚函数表的间接引用；由于调用地址事先未知，还可能存在处理器指令缓存未命中的惩罚。*

解决方法：**在性能关键区域避免这些调用**
```C++
class BaseClass
{
	public:
	virtual char *GetPointer()=0;
};
class Class"! : public BaseClass
{ 
	virtual char *GetPointer();
};
class Class2 : public BaseClass
{ 
	virtual char *GetPointer();
}|
void Function(BaseClass *pObj)
{ 
	char *ptr = pObj->GetPointer();
}
```
在上述函数中，如果FunctionQ对于性能至关重要，则需要将`BaeseClass::GetPointer`的调用从虚函数改为内联函数。****一种方法是向`BaseClass`添加一个新的受保护数据成员，并在每个类中设置该类数据成员***:
```C++
class BaseClass 
{
	public:
		inline char *GetPointerFast(){
			return mPointer;
		}
		protected:
			inline void SetPointer(char *pData)
			{
			mpData=pData;
			}
			private:
				char *mpData;
};
//类 class1 和类 class2 在成员函数中根据需要调用 SetPointer 
void Function(BaseClass *pObj)
{
	char *ptr =pObj-> GetPointerFast();
}
```
如果 `Classl` 和 `Class2` 只有细微的差别，将它们合并为一个类，通过一个标志在运行时决定类的行为方式，可能是一个更激进的措施。*这样做的改变（以及删除纯虚基类 BaseClass）可以使上一个示例中的 GetPointer 函数再次内联。这种转变远非优雅，但在小缓存的机器上的内层循环中，为了消除虚函数调用，你愿意做更糟糕的事情*。
> 尽管每个新的虚函数只增加了一个指针的大小到每个类的表中（通常是一个可以忽略的成本），但在类中的虚函数 yzrtf 需要在每个对象的基础上指向虚函数表。这意味着在小且经常使用的类中，你根本不希望有任何虚函数，因为这额外的开销是不可接受的。由于继承通常需要使用一个或多个虚函数（至少需要一个虚析构函数），对于小且频繁使用的对象，你也不想有任何层次结构。

### 代码尺寸
编译器在生成 C++代码方面有点声名狼藉，因为它们生成的代码往往臃肿。由于内存有限，而且小就是快，因此重要的是尽可能使可执行文件保持小巧。**首先要做的是让编译器站在你这边。如果你的编译器在可执行文件中存储调试信息，请禁用调试信息的生成**。

> 注意：Microsoft Visual C++将调试信息存储在可执行文件之外，因此这可能不是必需的。

异常处理会生成额外代码；尽可能消除生成异常的代码。确保链接器配置为删除未使用的函数和类。启用编译器最高级别的优化，并尝试将其设置为优化大小而不是速度——有时这实际上会产生更快的代码，因为更好的指令缓存一致性。除调试打印语句中所有浪费空间的字符串，并让编译器将重复的常量字符串合并为单个实例。

**内联通常是导致可疑大函数的罪魁祸首**。*编译器可以自由地尊重或忽略你的内联关键字，而且它们可能会在不告诉你的情况下内联函数*。这是另一个保持你的构造函数轻量的原因，这样堆栈上的对象就不会生成大量的内联代码。另外也要小心重载运算符；像 `ml = m2 * m3` 这样的简单表达式可能会生成大量的内联代码。
> 如果 m2 和 m3 是矩阵，请了解您的编译器设置以进行函数内联。

启用运行时类型信息(`RTTI`)需要编译器为（几乎）程序中的每个类生成一些静态信息。通常启用 RTTI 是为了让代码能够调用 `dynamic_cast` 并确定对象的类型。考虑完全避免 `RTTI` 和 `dynamic_cast`，以节省空间（此外，`dynamic_cast` 在某些实现中非常昂贵）。相反，当你确实需要根据类型有不同的行为时，添加一个表现不同的虚函数。这无论如何都是更好的面向对象设计。（注意，这不适用于 `static_cast`，它和 C 风格的强制转换在性能上一样。）

### 标准模板库
STL是一组用于实现常见的数据结构和算法的模板，如果动态数组、集合和映射。使用STL可以节省原本用于自己编写和调试这些容器所花费的大量时间。*然而，如果想要获得最大的代码效率，那么需要了解STL的具体实现细节*
为了允许最大范围的实现，***STL 标准在内存分配方面保持沉默。STL 容器上的每个操作都有一定的性能保证***
需要注意的是如果你使用了STL，那么***容器内存的使用是没办法得到保证的***
如果你只想存储一堆对象。通常你希望每个对象只在列表中出现一次，这样你就不用担心如果对象已经在集合中，还会不小心将其插入。STL集合会忽略重复项，插入、删除和查找的时间复杂度都是`O(log n)` ——虽然大多数操作集合都是`O(log n)`，这意味着对该算法忽略了前面的常数`C`。管集合的内存使用取决于实现，但许多实现基于红黑树，树中的每个节点存储集合的一个元素。通常的做法是*每次插入元素时分配一个树节点，每次删除元素时释放一个树节点。根据你插入和删除元素的频率，内存分配器花费的时间可能会超过使用集合所获得的任何算法节省*
一种替代方案使用 STL vector 来存储元素。vector 保证在集合末尾具有摊销常数时间的插入。这在实践中意味着 vector 通常只在偶尔重新分配内存。
从集合中删除的时间复杂度是 `O(log n)`，这看起来很快，但考虑到它可能还涉及一个` free()`调用。从向量中删除的时间复杂度是 O(n)，因为从删除元素到向量的末尾的所有元素都必须被复制到上一个位置。然而，如果向量的元素只是指针，所有的复制都可以在一个 `memcpyO` 调用中完成，这通常非常快。
> 这就是为什么通常最好在 STL 集合中存储对象指针而不是对象本身的原因。如果你直接存储对象，在删除等操作期间会调用许多额外的构造函数。

如果你仍然不认为集合和映射通常比它们更有用，请考虑迭代一个集合的成本，特别是：
```C++
for (Collection::iterator it = collection.begin();
	it != collection.end(); ++it)
```

> 如果上述的集合是一个向量，那么 ++it 是一个指针增量——一个机器指令。但当集合是一个集合或映射时，++it 涉及遍历到红黑树的下一个节点，这是一个相对复杂的操作，也更有可能导致缓存未命中，因为树节点可能分散在内存的各个地方。
> 如果你在集合中存储了大量的项目，并且进行了很多成员查询，那么集合的 O(log n) 性能很可能值得内存成本。类似地，如果你只是不经常使用这个集合，那么性能差异可能并不重要。你应该进行性能测量来确定什么值的 n 使集合更快。你可能惊讶地发现向量在游戏通常使用的所有值上都优于集合。

然而，关于 STL 内存使用这并非最终定论。**重要的是要知道当调用 clear()方法时，一个集合是否真的会释放其内存。如果不是，可能会导致内存碎片化**。
如何解决从空向量启动后重新开始时clear()不能完全释放内存导致内存碎片化的问题：
> 首先，你可以在创建向量时调用 reserve()，预留足够的空间以容纳你将需要的最大元素数量。如果这不可行，你可以通过以下方式显式地强制向量释放其内存：
> ```C++
> vector v; // ...元素被插入到 v 中 
> vector().swap(v);
> ```

集合、列表和映射通常不会出现这个问题，因为它们会单独分配和释放每个元素。

### 高级特性
**并非所有语言都具备某个特性那么意味着你必须使用它**。看似简单的特性可能会有非常糟糕的性能，而其他看似复杂的特性实际上可能性能很好。C++ 最黑暗的角落高度依赖于编译器——在使用它们之前，确保你知道其代价。
***C++ 字符串是一个听起来很好但在性能重要时应该避免的特性***

对于下述代码：
```C++
void Function(const std::string &str)
{
//...
}
Function("Hello")
```
>对 FunctionQ 的调用会为字符串调用一个构造函数，给定一个 `const char *`。在一个商业实现中，这个构造函数执行了 `mallocQ`、`strlenQ` 和 `memcpyO`，而析构函数立即执行了一些非平凡的工作（因为这种实现中的字符串是引用计数的），然后是` freeQ`。分配的内存基本上是浪费的，因为字符串 `"hello"` 已经在程序的数据段中；我们实际上在内存中重复了它。如果 `FunctionQ `被声明为接受一个 `const char *`，调用将没有任何开销。


模板是效率相反的极端例子。根据语言标准，编译器在模板用特定类型实例化时生成代码。理论上听起来，一个模板声明会导致大量几乎相同的代码。如果你有一个 Class1 指针的向量和一个 Class2 指针的向量，你会在可执行文件中最终得到两个 vector 的副本。

对于大多数编译器来说，现实情况通常更好。首先，只有那些实际被调用的模板成员函数才会为其生成代码。其次，如果正确行为得以保持，编译器被允许只生成一份代码。通常你会发现，在之前给出的向量示例中，只会生成一份代码（可能是针对 vector 的）。给定一个优秀的编译器，模板为你提供了通用编程的所有便利，同时保持了高性能。

C++ 的一些特性，如初始化列表和前置自增，通常会提高性能，而其他一些特性，如重载运算符和 RTTI，看起来同样无害，但会带来严重的性能损失。STL 集合说明了盲目信任函数的文档算法运行时间可能会让你误入歧途。避免语言和库中潜在的低效特性，并花费一些时间熟悉你的分析器和编译器中的选项。你会很快学会为速度设计并找出游戏中的性能问题。

## Inline Functions Versus Macros
> **Author**:Peter Dalton, Evans & Sutherland
> 
> Contact: pdalton@xmission.com

本篇主要讨论了
### 内联函数的优点
1. 使用内联函数可以有效地避免宏定义的一些固有缺点：
```C++
#define max(a,b)((a)>(b)?(a):(b))
```
若调用上述的宏，并且设置x=5,j=3，那么宏的返回值则是7而不是预期的6——这里是由于宏的最常见的副作用即传递的参数会被多次执行求值。
要避免此副作用，最好使用内联函数来实现：
```C++
inline int max(int a, int b)
{
return (a>b ? a : b);
}
```

**通过使用内联方法，我们保证所有参数只被求值一次，因为它们必须遵循所有在普通函数上强制执行的协议和类型安全。**

 宏的另一个缺点是**运算符优先级**，例如以下的宏：
 ```C++
 #define square(x) (x*x)
```
如果使用`2+1`调用该宏，那么会返回的值是5而不是预期的9，原因在于乘法运算符的优先级显著高于加法运算符。

最令人恼火的部分是多语句宏，以及确保宏中的所有语句都能够正确的执行。

以下述的宏进行讨论：
```C++
#define clamp(a) \
	if (a >1.0) a=1.0; \
	if  (a<0.0) a=0.0; \
```
在以下的代码中循环使用宏：
```C++
for (int ii=0;ii<N;ii++)
	{
	clamp(numbersToBeClamped[ii])}
```
如果它们小于零，则不会对数字进行限制。只有当 for 循环终止时，当`ii == N` 时，表达式 `if(numbersToBeClamped[ii] <0.0) `需要被评估。这也是一个很严重的问题，因为索引变量 `ii` 现在是超出范围，很容易导致内存边界违规，从而崩溃程序。虽然用内联函数替换宏以执行相同功能并非唯一解决方案，但它是最干净的。
于宏的这些固有缺点，让我们来看看内联函数的优点：
- 内联函数**遵循对普通函数强制执行的类型安全协议**。这确保了不会将意外或无效的参数作为参数传递
- ***内联函数的指定方式与其他任何函数相同，只是在函数声明中添加了 inline 关键字***。
- 作为内联函数参数传递的表达式在进入函数体之前被评估；因此，*表达式只被评估一次*。如前所示，传递给宏的表达式可能会被多次评估，并可能导致不安全和意外的副作用。
- **使用 Microsoft 的 Visual C++ 等调试器可以调试内联函数**。而宏则不行，因为宏是在解析器接管并创建程序的符号表之前展开的。
- **内联函数无疑增加了过程的可读性和可维护性，因为它们使用与普通函数调用相同的语法，但不会意外地修改参数**。
内联函数还优于普通函数，通过消除函数调用的开销。这包括栈帧设置、参数传递、栈帧恢复和返回序列等任务。除了这些主要优势外，内联函数还为编译器提供了执行改进代码的优化能力。
**通过将内联函数替换为代码，插入的代码可以受到额外的优化，这是以前不可能的，因为大多数编译器不会执行跨过程优化**
允许编译器**执行全局优化**，如公共子表达式消除和循环不变量消除，可以显著提高速度和大小
**联函数的唯一限制，在宏中不存在的是参数类型的限制。宏允许任何可能的类型作为参数；然而，内联函数只允许指定的参数类型以强制类型安全**，要解决这个问题我们可以使用内联模板函数来克服这个限制。

### 何时使用内联函数
当然，内联函数是一个十分优秀的工具，但是用不好依旧会让你的代码变得十分的糟糕。至于为什么不能每个函数都使用内联函数，因为这样会导致代码过分地膨胀，带来的负作用已经远超过其带来的速度变快的好处。
在评估程序性能时，需要权衡两个因素：执行速度和实际代码大小。增加代码大小会占用更多内存，而内存是宝贵的资源，同时也会降低执行速度。随着程序内存需求的增加，缓存未命中和页面错误的概率也会增加。虽然缓存未命中会导致轻微的延迟，但页面错误总会导致较大的延迟，因为虚拟内存位置不在物理内存中，必须从磁盘获取。

所以如何使用内联函数，以及何时使用它？
以下有一些内联函数工具良好工作的指南：
- 小方法
- 返回对象状态信息的方法
- 小函数，通常三行或者更小
- 反复调用的简短函数

**花费在调用/返回序列中时间比例较长的函数将不太受益于内联。然而，正确使用内联可以大大提高过程性能。**
### 何时使用宏？
尽管宏存在一些问题，但在某些情况下它们非常有价值。
宏可用于创建小型伪语言，这些语言可以非常强大。一组宏可以提供创建状态机的框架，同时非常易于调试且健壮。
**避免与宏相关问题的关键在于，首先理解问题，其次了解替代实现方案**

### Microsoft 特有功能
除了标准的内联关键字外，微软的Visual C++编译器还提供了两个额外的关键字支持。内联关键字指示编译器进行成本效益分析，并且只有当它证明是有益的时候才内联该函数。
forceinline 关键字指示编译器始终内联该函数。尽管使用了这些关键字，但在某些情况下编译器可能无法遵守，正如微软的文档MSDN中所述

## Programming with Abstract Interfaces
 > Author : Noel Llopis,Meyer/Glass Interactive
 > Contact: nllopis@miggames.com
 
 抽象接口的概念简单而强大。它允许我们完全将接口与其实现分离。这带来了一些非常有用的后果：
 - 我们可以轻松地在代码中切换不同的实现，而不会影响游戏的其他部分。
 - 实现可以在运行时更改。
 - 接口的实现细节对接口的使用者完全隐藏。
 - 新的声音系统实现可以毫不费力地添加到游戏中，甚至可能是在游戏编译和发布之后。

### 抽象接口
在 C++中，抽象接口只不过是一个只有公共纯虚函数的基类。纯虚函数是一种没有实现的虚拟成员函数。任何派生类都必须实现这些函数，否则编译器会阻止该类的实例化。纯虚函数通过在其声明后加上`=0 `来表示。
抽象接口完全不提供任何实现。**它所做的一切只是定义了其他所有事物使用声音系统的规则**


## Protect Yourself from DLL Hell and Missing OS Functions
> Author: Herb Marselas, Ensemble Studios 
> 
> Contact: hmarselas@ensemblestudios.com

动态链接库（DLL）是 Microsoft Windows 的一个强大功能。它们有很多用途，包括共享可执行代码和抽象设备差异。
依赖 DLL 可能会因为它们的独立性质而出现问题。*如果应用程序依赖的 DLL 在用户计算机上不存在，尝试运行它将导致一条“找不到 DLL”的消息，这对普通用户没有帮助*。
DLL地狱：在用户计算机上存在所谓的DLL，但是计算机需要找到和加载该DLL才能够正确运行
### 隐式链接与显式链接
防止不良 DLL 的第一道防线是**确保用户计算机上存在必要的 DLL，并且是应用程序可以工作的版本**。这必须在尝试使用它们的功能之前完成。
DLL 通过**在链接行中指定相应的 lib 文件来链接到应用程序**。这被称为***隐式 DLL 加载，或隐式链接***。通过链接到lib文件，操作系统将自动搜索并加载匹配的DLL当程序运行时。这种方法假设DLL存在，WIndows可以找到它，并且它是与程序可以工作的版本。

> 微软 Visual C++ 还支持三种其他隐式链接方法。首先，将 DLL 的 lib 文件直接包含到项目中，就像在链接行中添加它一样。其次，如果项目包含一个构建 DLL 的子项目，则 DLL 的 lib 文件默认情况下，库会自动与项目链接。最后，可以使用 `#pragma comment (lib "libname")` 指令将库链接到应用程序。

解决隐式链接和加载这种情况的补救措施是显式加载 DLL。这是通过不在链接行中链接到 DLL 的 lib 文件，并删除任何会链接到库的 `#pragma comment` 指令来完成的。

### 加载库和获取过程地址
当使用库文件隐式加载DLL时，函数可以直接在应用程序的代码中调用，而操作系统加载器会处理所有加载DLL和解析函数引用的工作。
当切换到显式链接时，函数必须通过手动解析的函数指针间接调用。为此，**必须使用 LoadLibrary 函数显式加载包含函数的 DLL，然后我们可以使用 GetProcAddress 获取函数的指针**。
```C++
HMODULE LoadLibrary(LPCTSTR lpFileName);
FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
BOOL FreeLibrary(HMODULE hModule);
```

`LoadLibrary `会搜索指定的 DLL，如果找到，则将其加载到应用程序进程空间中，并返回一个指向该新模块的句柄。然后使用 `GetProcAddress `创建指向 DLL 中每个将要被游戏使用的函数的函数指针。当显式加载的 DLL 不再需要时，应使用` FreeLibrary `释放它。调用 `FreeLibrary` 后，模块句柄不再被视为有效。
每次调用 `LoadLibrary` 都必须匹配一次调用 `FreeLibrary`。这是必要的，因为 Windows 在每个进程中为每个加载的 DLL 增加一个引用计数，无论是隐式由可执行文件或其他 DLL 加载，还是通过调用 LoadLibrary。通过调用 FreeLibrary 或卸载加载此 DLL 的可执行文件或 DLL，该引用计数会减少。当给定 DLL 的引用计数达到零时，Windows 知道它可以安全地卸载该 DLL。
### 防范DirectX
我们发现的一个常见问题是 DirectX 组件所需的版本未安装，或者安装损坏。为了保护我们的游戏免受这些问题的影响，我们明确加载所需的 DirectX 组件。
如果我们要在 DirectX 8 中隐式链接到 DirectInput，我们会将 `dinput8.lib` 添加到我们的链接行，并使用以下代码：
```C++
IDirectlnputS *pDInput;
HRESULT hr = DirectInput8Create(hInstance, DIRECTINPUT_VERSION,
IID_IDirectInput8,
(LPVOID*) & pDInput, 0)；
if (FAILED(hr))
{ 
	// handle error - initialization error
}
```

显式 DLL 加载情况实际上增加了两行代码，但应用程序现在可以防止 `dinput8.dll` 未找到或以某种方式损坏。
```C++
typedef HRESULT (WINAPI* DirectInput8Create_PROC)
(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf,
LPVOID* ppvOut,
LPUNKNOWN punkOuter);
HMODULE hDInputLib = LoadLibrary( "dinput8.dll");
if (! hDInputLib)
{
// handle error - DInput 8 not found. Is it installed incorrectly
// or at all?
}
DirectInput8Create_PROC diCreate;
diCreate = (DirectInput8Create_PROC)
GetProcAddress(hDInputLib, "DirectlnputSCreate") ;
if (! diCreate)
{ // handle error - DInput 8 exists, but the function can't be found
}
HRESULT hr = (diCreate) (hlnstance, DIRECTINPUT_VERSION,
I ID_IDirect Inputs,
(LPVOID*) &mDirectInput, NULL);
if (FAILED(hr))
{ // handle error - initialization error
}
```

首先，创建一个函数指针` typedef`，它反映了函数 `DirectlnputSCreate`。然后使用` LoadLibrary` 加载 DLL。如果 `dinput8.dll` 成功加载，我们尝试找到函数 `DirectlnputSCreate`。
使用 LoadLibrary 加载 DLL。如果 dinput8.dll 成功加载，我们尝试找到函数 DirectlnputSCreate。

`GetProcAddress`。`GetProcAddress`如果找到函数，则返回函数的指针，如果找不到函数，则返回 NULL。然后我们检查以确保函数指针是有效的。最后，我们通过函数指针调用 `DirectInputSCreate` 来初始化 `DirectInput`。
> 如果需要从 DLL 中检索更多函数，则会对每个函数声明一个函数指针类型定义和变量。在映射第一个函数指针时，仅检查 NULL 可能就足够了。然而，由于通常不会做错误处理是件坏事，因此检查每个 GetProcAddress 以确保返回值非 NULL 可能是件好事。

使用操作系统特定功能

另一个显式加载 DLL 可以解决的问题是**在应用程序想要利用特定 API 函数时，如果该函数可用**。
使用 `LoadLibrary` 和 `GetProcAddress` 也可以应用于游戏 DLL。

> 然而，支持 Direct3D 的 DLL 链接隐式地与 dddS.lib 链接，而支持 OpenGL 的 DLL 链接隐式地与 opengl32.lib 链接。主执行文件通过显式加载游戏自有的 DLL，而每个图形子系统通过隐式加载解决了几个问题。首先，如果尝试加载任一库失败，很可能是因为特定的图形子系统文件找不到或已损坏。然后，主程序可以优雅地处理错误。这个问题解决的另一个方面，对于 OpenGL 来说比 Direct3D 更明显，如果引擎显式链接到 OpenGL，它需要为每个使用的 OpenGL 函数定义 typedef 和函数指针。隐式链接到支持 DLL 解决了这个问题。

### 总结摘要
***显式链接***可以作为防止 Windows 下遇到的一些常见 DLL 问题的屏障，*包括缺失的 DLL 或与应用程序不兼容的 DLL 版本*。虽然它不是万能药，但至少可以让应用程序掌控局面，并允许任何错误被优雅地处理，而不是以一个模糊的错误消息或直接崩溃的方式。

注意避免DLL地狱，这是一个对玩家很糟糕的东西，尽量能避免就避免

## Dynamic Type Information
> Author : Scott Wakeling, Virgin Interactive
>
> Contact: scott@chronicreality.com
> 

这个技巧讨论了通过提供查询它们与其他类型关系的方法，或访问它们类型在运行时的信息来进行有效管理类型。在技巧的末尾，提出了一种支持持久对象的方法，并提供了一些关于如何扩展该方法的想法。

### 介绍动态类型信息类
为了有效地利用我们的类型的强大功能，我们将转向一个特定类的帮助：**动态类型信息（DTI）类**。*这个类将存储我们可能需要的关于任何给定对象或结构的类型的信息*。这里给出了该类的最小实现：
```C++
class dtiClass
{
	private:
		char* szName;
		dtiClass* pdtParent;
	public:
		dtiClass();
		dtiClass(chaR* szSetName, dtiClass *pSetParent);
		virtual -dtiClass();
		const char* GetName();
		bool SetName(char* szSetName);
		dtiClass* GetParent();
		bool SetParent(dtiClass* pSetParent);
};
```

为了将 DTI 集成到我们的引擎中，我们所有的类都需要一个名为 `dtiClass` 的静态成员。正是这个类允许我们为了调试目的访问类名，并查询类父级的 `dtiClass` 成员。这个成员必须贯穿整个类树，从根类一直向下，从而确保所有游戏对象都能访问到关于自身及其父级的信息。`dtiClass` 的实现可以在随附的 CD 光盘中的代码中找到。

### 暴露和查询DTI
通过实现之前描述的非常简单的类树。这里是一个代码片段，展示了一个帮助我们定义静态 `dtiClass` 成员、一个基本的根类以及类类型信息的简单初始化的宏：
```C++
#define EXPOSE_TYPE \
	public: \
		static dtiClass Type;
class CRootClass
{
	public:
		EXPOSE_TYPE;
		CRootClass() {};
		virtual -CRootClass() {};
};
dtiClass CRootClass::Type( "CRootClass", NULL )
```

我们传递类名和指向类父级的 dtiClass 成员的指针。dtiClass 构造函数会做其余的工作，相应地设置 szName 和 pdtiParent 成员。
现在我们可以查询对象在运行时的类名，用于调试或其他与类型相关的用例，例如**保存或加载游戏**。
```C++
// Let's see what kind of object this pointer is pointing to
const char* szGetName = pSomePtr->Type.GetName();
```

### 继承意味着"IsA"
面向对象给了我们继承的力量。随着继承而来的是多态性，即**所有对象在任何时候都可以是多种类型中的一种的能力**。
在许多情况下，多态性被用于游戏编程中，以安全、动态和有效的方式处理多种类型的对象。这意味着我们希望在将它们强制转换为兼容类型之前确保对象是兼容的，从而防止未定义行为。这也意味着我们希望能够在运行时检查对象符合哪种类型，而不是在编译时就需要知道，并且我们希望所有这些操作都能够快速轻松地完成。

### 处理通用对象

作为我们运行时类型信息解决方案的一部分，我们拥有 IsA 和 SafeCast 例程，可以查询对象的通用类型，并安全地将它向上转换到类树。这通常被称为***向上转型***，它使我们能够以快速、安全且通用的方式处理大量游戏对象。问题的另一半是**向下转型**——*将指向通用基类的指针安全地转换为更专门的子类。如果我们想迭代一个根类指针列表，并检查每个指针是否真的指向特定类型的子类，我们需要使用 C++引入的动态转换运算符*。

动态转换运算符用于在多态类型之间进行转换，它既安全又具有信息性。它甚至可以返回有关尝试转换的适用反馈。它采用以下形式：
```C++
dynamic_cast<type_id>(expression)
```
我们必须传入的第一个参数是在强制转换之后，我们希望表达式符合的类型。这可以是我们类的一个指针或引用。如果是指针，传入的表达式参数也必须是指针。如果我们传入一个类的引用，那么在第二个参数中，我们必须传入一个可修改的左值。这里有两个例子：
```C++
//给定一个根对象，一个指针，我们可以这样进行向下转型
CChildClass *pCHild = dynamic_cast<CChildClass*>(pRoot)；
CChildClass *pCHild = dynamic_cast<CChildClass*>(RootObj)；
```

要获得这些扩展转换操作符的访问权限，我们需要在编译器设置中启用嵌入式运行时类型信息（对于 Microsoft Visual C++，使用/GR 开关）。如果请求的转换无法进行（例如，如果根指针实际上并没有指向一个更派生的对象），操作符将简单地失败，表达式将评估为 NULL。
在前面的代码片段中，如果`pChild `会被评估为`NULL`，且`pRoot`真的只会指向一个`CRootClass`对象。
`dynamic_cast` 运算符让我们能够确定指针后面真正隐藏的类型。给定一个通用的 `CRobot` 指针列表，我们可以遍历这些指针并对每个进行 `dynamic cast`，检查哪些成功，哪些解析为 `NULL`，从而确定哪些实际上是机械的。最后，我们现在可以安全地进行向下转型，这也完成了我们的运行时类型信息解决方案。

### 实现持久型类型信息

## A Property Class for Generic C++ Member Access
> Author: Charles Cafrelli
>
>Contact: skywise@iquest.net

## Adding Deprecation Facilities to C++
> Noel Llopis, Meyer/Glass Interactive
>
> Contacts: nllopis@mgigames.com

在很多情况下，一个游戏引擎在其生命周期内其函数接口灰发生很多次的变化，有的甚至会被完全取代，当其函数接口更新时有概率会导致游戏根本无法继续编译。
### 可能的解决方案
这里有两种方法来处理这种情况：
- **什么也不做**。每次有变化时，每个人都必须更新调用更改函数的代码才能继续工作。(当团队人数过多的时候这是完全不能接受的)
- **不要更改任何接口**。这也很明显是不现实的，由于硬件、需求等方面的改变，函数接口是会常常发生变化的。*坚持这种方法通常会造成更多伤害而不是好处，最终导致函数或类名与其真正作用完全无关，并且语义完全过载*。
- **创建新的接口**，通过创建新的接口可以在一定程度上避免上述两个解决方案带来的问题，这是一种很取巧的解决方法，对于那些不经常更新的项目来说，是一个很不错的方案，但是一旦项目开始进入频繁变动的时期，这个方案则会带来API地狱——无尽的API旧接口。

### 理想的解决方案
我们真正想要的是能够编写一个新的接口函数，但暂时保留旧的接口函数。这样，团队的其他成员可以立即开始使用新的函数。他们可以在任何时候将旧代码更改为使用新函数，一段时间后，当没有人再使用它时，就可以将其移除。

问题是，***如何让每个人都知道哪些函数已经更改，以及他们应该使用哪些函数。即使我们一直告诉他们这些，如果一切都能编译和正常运行，他们又如何记住呢***？
> 我们编写新的函数，然后将旧的函数标记为弃用。然后，每当使用旧的函数时，编译器都会生成一条消息，解释正在调用一个弃用的函数，并提及应该使用哪个替代函数。

### 使用和分配已弃用的函数
由于C++不支持使用内置的方式来标记启用。我们得去实现一套支持弃用的代码：
```C++
int FunctionA(void)
DEPRECATE("FUNCTIONA()","NEW FUNCTIONA()")
//Implementation
int NewFunctionA(void)
{
	//Implementation
}
```
该行 `DEPRECATE("FunctionA()", "NewFunctionAQ")` 表示 `FunctionAQ` 已弃用，并且已被 `NewFunctionAQ` 替代。

`FunctionAQ` 的用户根本不需要做任何特别的事情。每当用户使用 FunctionA() 时，在退出程序时，他们会在调试窗口中看到以下消息：
```TXT
WARNING. You are using the following deprecated functions:
- Function FunctionA() called from 3 different places.
Instead use NewFunctionA().
```
如果没有任何已弃用的函数，它将永远不会被创建，并且在程序执行结束时也永远不会打印任何报告。在内部，`DeprecationMgr` 通过 `STL map` 集合以函数名称为索引，**为每个已弃用的函数保持一个小的结构。只有对已弃用函数的第一次调用才会将新条目插入到映射中。**

`DeprecationMgr` 类还有一个小小的优点：**它会跟踪每个已弃用函数被调用过的不同位置的数量**。这很有用，这样我们一眼就能知道当我们决定停止使用已弃用函数时需要在代码的多少地方进行更改。不幸的是，由于这个技巧直接使用汇编语言，它是平台特定的，并且只能在 x86 系列的 CPU 上工作。DEPRECATE 宏的前两行获取 EBP 寄存器（通常可以从其中检索返回地址），并将其传递给 AddDeprecatedFunc-然后如果同一个地方调用一个函数多次（例如在循环中），它只会被报告为从一处调用。

>这种获取返回地址的方法存在一个潜在问题。
>
通常情况下，地址 `[EBP-4]` 包含当前函数的返回地址。然而，在某些情况下，编译器可能不会将 EBP 寄存器设置为预期值。特别是当在 VC++ 6.0 中开启编译器优化，并且针对特别简单的函数时，这种情况会发生。在这种情况下，尝试从 `[EBP-4]` 读取可能会返回不正确的值或导致程序崩溃。在发布模式下（通常开启优化），由于宏不执行任何操作，因此不会有问题。但是，有时调试模式下也会使用优化，因此在我们尝试从 `[EBP-4] `读取返回地址时，我们只尝试读取当前进程可读的地址。这是通过使用异常处理或调用 Windows 特有的函数 IsBadReadPtrQ 来实现的。当开启优化时，这会导致弃用函数调用次数计数不正确，但至少不会导致程序崩溃，并且弃用管理器的其他功能仍然可以正常工作。

### 进一步工作

一个主要问题仍然存在：***弃用警告是在运行时生成的，而不是在编译时或链接时生成的***。这是必要的，因为弃用的函数可能存在于一个单独的库中，而不是正在编译的代码中。仅在运行时报告弃用函数的主要缺点是，程序仍然可能在使用一个弃用的函数，该函数被调用的频率足够低，以至于从未被发现。直到最终删除该函数并且编译器报告错误之前，可能都不会检测到该函数的使用。

## A Drop-in Debug Memory Manager
> Author: Peter Da/ton, Evans & Sutherland
>
> Contact: padalton@xmission.com

随着游戏编程的复杂性增加，对资源的管理是十分重要的，内存管理器正是在这里发挥作用的地方。通过创建几个简单的内存管理例程，我们将能够跟踪所有动态分配的内存，并引导程序实现最佳内存使用。我们的目标是确保合理的内存占用，通过报告内存泄漏、跟踪实际使用的已分配内存百分比，并提醒程序员边界违规。我们还将确保与内存管理器的接口无缝衔接，这意味着它不需要任何显式的函数调用或类声明。我们应该能够将这段代码通过包含头文件轻松地插入到任何其他模块中，并让其他一切都顺利运行。
创建内存管理器的缺点包括内存管理器分配内存、释放内存以及查询内存以获取统计信息所需的时间开销。因此，这并不是我们希望在游戏最终构建中启用的选项。为了避免这些陷阱，我们将仅在调试构建期间启用内存管理器，或者当符号 `ACTIVATE_MEMORY_MANAGER` 被定义时启用。

### 入门

内存管理器的核心在于***重载标准的 `new` 和 `delete` 运算符***，以及使用`#define` 来创建一些宏，这些宏使我们能够插入我们自己的
使用自己的内存分配和释放例程，我们将能够用我们自己的内存跟踪模块替换标准例程。这些例程将记录内存分配请求所在的文件和行号，以及统计信息。

 第一步是**创建重载的 new 和 delete 运算符**。如前所述，我们希望记录请求内存分配的文件和行号。当尝试解决内存泄漏时，这些信息将变得无价，因为我们将能够追踪内存分配到其根源。以下是一个代码示例：
```C++
inline void * operator new(size_t size, const char *file, int line);
inline void* opterator new[](size_t size,const char *file,int line);
inline void operator delete(void *address);
inline void operator delete[](void *address);
```
需要注意的是，新的 `new` 和 `delete` 操作符的标准版本和数组版本都需要重载以确保正常功能。**虽然这些声明看起来并不复杂，但目前我们面临的问题是获取所有将使用内存管理器的例程，以便无缝地将额外的参数传递给 new 操作符。**这就是#define 指令发挥作用的地方。
```C++
#define new new( FILE , LINE )
tfdefine delete setOwner(_FILE_,_LINE_) .false ? setOwner("",0)
: delete
#define malloc(sz) AllocateMemory(_FILE_,_LINE_,sz,MM_MALLOC)
tfdefine calloc(num,sz)
AllocateMemory(_FILE_1_LINE_,sz*num,MM_CALLOC)
#define realloc(ptr,sz) AllocateMemory( FILE , LINE , sz,
MM_REALLOC, ptr )
tfdefine free(sz) deAllocateMemory( FILE , LINE , sz,
MM_FREE )
```
`#define new` 语句将替换所有`new` 调用，使用我们自定义的 new，它不仅接受分配请求的大小作为参数，还接受用于跟踪的文件和行号。Microsoft 的 Visual C++ 编译器提供了一套预定义宏，其中包括我们所需的 `__FILE__` 和` __LINE__ `符号 [MSDN]。`#define delete` 宏与 `#define new` 宏略有不同。无法在不创建语法问题的情况下向重载的 `delete `操作符传递额外参数。相反，`setOwnerQ` 方法记录文件和行号以供后续使用。请注意，创建宏作为条件也很重要，以避免与多行宏相关联的常见问题 [DaltonOl]。最后，为了完整，我们还替换了 mallocQ、callocQ、reallocQ 和 freeO 方法，使用我们自己的内存分配和释放例程。

### 内存管理器日志记录
现在我们已经提供了替换标准内存分配例程的必要框架，我们可以开始记录日志。正如本技巧开头所述，*我们将专注于内存泄漏、边界违规以及实际内存需求*。为了记录所有所需信息，我们首先需要选择一个数据结构来存储与内存分配相关的信息。为了高效和速度，我们将使用链式哈希表。每个哈希表条目将包含以下信息：
```C++
struct MemoryNode
{
	size_t actualSize;
	size_t reportedSize;
	void *actualAddress;
	void *reportedAddress;
	char sourceFile[30];
	unsigned short sourceLine;
	unsigned short paddingSize;
	char options;
	long predefinedBody;
	ALLOC_TYPE allocationType;
	MemoryNode *next, *prev;
}
```
这个结构体包含了不仅为用户分配的内存大小，还包括为分配的内存块开头和结尾添加的填充大小。*我们还记录了分配的类型，以防止分配/释放不匹配的情况*。
此时，我们应当已经拥有所有必要的信息来判断程序中是否存在内存泄漏。通过在 `AllocateMemoryO`例程中创建一个 `MemoryNode `并将其插入哈希表中，我们将记录所有已分配内存的历史。然后，通过在 `deAllocateMemoryO`例程中移除 `MemoryNode`，我们将确保哈希表仅包含当前已分配内存的列表。如果程序退出时哈希表中仍有条目残留，则发生了内存泄漏。此时，可以通过查询 `MemoryNode` 向用户报告内存泄漏的详细信息。如前所述，在 `deAllocateMemoryO` 例程中，我们还将验证该方法用于分配内存的方式必须与释放内存的方式相匹配；如果不匹配，我们将注意到潜在的内存泄漏。
接下来，让我们收集与边界违规相关的信息。边界违规发生在应用程序超出为其分配的内存时。这种情况最常发生在访问数组信息的循环中。例如，如果我们分配了一个大小为 10 的数组，而我们访问了数组位置 11，我们就会超出数组边界，并覆盖或访问不属于我们的信息。为了防止这个问题，我们将为分配的内存前后提供填充。因此，如果例程请求 5 个字节，`AllocateMemoryO`例程实际上会分配`(5 + sizeof(long long) * 2 * paddmgSize)`字节。请注意，我们使用 long 类型作为填充，因为它们被定义为 32 位整数。接下来，我们必须将填充初始化为一个预定义的值，例如 `0xDEADCODE`。然后，在释放内存时，如果我们检查填充并发现任何值不是预定义的值，我们就知道发生了边界违规。此时，我们会查询相应的 `MemoryNode` 并向用户报告边界违规。
剩下的唯一信息是需要收集程序的内存实际需求。我们想知道分配了多少内存，分配的内存中有多少实际被使用，或许还需要峰值内存分配信息。为了收集这些信息，我们需要另一个容器。既然我们已经有了所有统计信息，现在让我们来讨论如何向用户报告这些信息。CD 中包含的实现将所有信息记录到日志文件中。一旦用户启用了内存管理器并运行了程序，在程序终止时就会生成一个日志文件，其中包含所有内存泄漏、边界违规以及最终的统计报告。
剩下的唯一问题是：***我们如何知道程序何时终止，以便我们可以输出日志信息***?一个简单的解决方案是要求程序员在程序终止时显式调用 dumpLogReport()例程。然而，这违背了创建无缝接口的要求。为了在不使用显式函数调用的方式下确定程序何时终止，我们将使用一个静态类实例
```C++
class Initialize
{ 
	public: Initialize() 
		{ InitializeMemoryManager(); } 
};
static Initialize InitMemoryManager;
bool InitializeMemoryManager() {
static bool hasBeenlnitialized = false;
if (sjnanager) 
	return true;
else if (hasBeenlnitialized) 
	return false;
else {
s_manager = (MemoryManager*)malloc(sizeof(MemoryManager));
s_manager->intialize();
atexit( releaseMemoryManager );
hasBeenlntialized = true;
return true;
}
}
void releaseMemoryManager() {
NumAllocations = sjnanager->m_numAllocations;
s_manager->release(); // Releases the hash table and calls
free( sjnanager ); // the dumpLogReport() method
sjnanager = NULL;
}
```
我们当前的问题是**确保内存管理器是第一个被创建的对象，也是最后一个被释放的对象**。由于静态定义的对象处理顺序，这可能很困难。例如，如果我们创建了一个静态对象，它在构造函数中分配了动态内存，而内存管理器对象尚未被分配，那么内存管理器将无法用于内存跟踪。同样，如果我们使用 ::atexit() 方法调用负责释放已分配内存的函数，内存管理器对象将在 ::atexit() 方法被调用之前被释放，从而导致虚假的内存泄漏。
改进方法：
1. 首先，通过在内存管理器的头文件中创建 InitMemoryManager 对象，可以保证它在任何静态对象声明之前被遇到。
***只要我们在任何静态定义之前包含那个内存管理器头文件，这一点就成立。***
2. 其次，为了确保内存管理器始终可用，我们将调用 `InitializeMemo`在 A`llocateMemoryO` 和 `DeallocateMemoryQ `中每次调用 `ryManager()`例程，确保内存管理器处于活动状态
3. 最后，为了确保内存管理器是最后一个被释放的对象，我们将使用 `::atexit()` 方法。`::atexit()` 方法通过以与传递给方法的顺序相反的顺序调用指定的函数来工作。
> 因此，对内存管理器唯一的要求是**它是第一个调用 ::atexit() 函数的方法**。*静态对象仍然可以使用 ::atexit() 方法；它们只需要确保内存管理器存在*。如果由于任何原因 `InitializeMemoryManagerQ` 函数返回 false，那么最后一个条件就没有得到满足，结果错误将在日志文件中报告。

虽然如果内存管理器在 s 的声明之前已经激活，这不会成为问题，但值得注意。尽管这个例子完全是 VC++特有的，其他编译器可能会有所不同，或者包含在幕后调用`::atexit()`的额外方法。解决问题的关键是确保内存管理器首先初始化。

### 注意事项
除了执行内存跟踪所需的额外内存和时间之外，还有几个其他细节需要注意。首先是关于在包含其他文件时可能遇到的语法错误。在某些情况下，由于其他文件重新定义了 new 和 delete 运算符，可能会生成语法错误。在使用 STL 实现时，这一点尤其明显。例如，如果我们先#include "MemoryManager.h"，然后#include ，就会生成各种错误。为了解决这个问题，我们将使用两个额外的头文件：new_on.h 和 new_off.h。这些头文件将简单地#define 和#undefine 之前创建的 new 和 delete 宏。这种方法的优点包括我们通过不强制用户遵守特定的#include 顺序所获得的灵活性，以及避免了在处理预编译头文件时的复杂性。
```C++
#include "new_off.h"
#include <map>
#include <string>
#include <ALL_THE_HEADERS_OVERLOADING_THE_NEW/DELETE_OPERATORS>
#include "new_on.h"
#include "MemoryManager.h"
#include "CUstom_Header_files"
```
另一个我们需要解决的问题是如何处理那些**重新定义` new` 和 `delete` 运算符的库**。例如，MFC 有自己的系统来处理 `new` 和 `delete` 运算符。因此，我们希望 MFC 类使用它们自己的内存管理器，而非 MFC 的共享游戏代码使用我们的内存管理器。我们可以通过在 `#//2&/'`由 `ClassWizard` 创建的注释后直接插入 `#include "new_off.h"` 头文件来实现这一点。
```C++
ifdef _DEBUG
#include "new_of.h"

```
这种方法将允许我们保留 MFC 内存管理器的优势，例如在内存泄漏时转储 CC%>rt 派生类，同时仍然为其余代码提供内存管理器。
最后，请记住正确实现'the setOwnerQ 方法的要求，该方法由 delete 运算符使用。必须认识到，实现比仅记录文件和行号更复杂；我们必须创建一个栈实现。这是由于我们实现 delete 宏的方式造成的
函数的调用顺序如下所示：
```txt
1. new( objects, File2, 1);
2. new( a, Filel, 1);
3. setOwner( File2, 2 );
4. setOwner( Filel, 1 );
5. delete( a );
6. delete( objects );
```
从前面的列表中应该很明显，当 delete 操作符被调用以释放 objectB 时，如果我们不使用栈实现，我们将不再拥有文件和行号信息。虽然解决方案很简单，但问题并不立即显而易见。
## A Built-in Game Profiling Module
> Author: JeffEvertt, Lithtech, Inc.
>
> Contact:jeff@evertt.com

## Linear Programming Model for Windows-based Games
> Author: Javier F.Otaegui, Sabarasa Entertainment
>
> Contact:Javier@sabarasa.com.ar

