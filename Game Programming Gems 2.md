本书主要是游戏有关的技术的论文集合，可以挑着看，没必要全部看完

## 1 Optimization for C++ Games 
> **Author:** Andrew Kirmse, LucasArts Entertainments
> Contact: ark@alum.mit.edu

这个技巧描述了你可以用来加速游戏的技术。它假设你已经确信使用 C++的好处，并且熟悉优化的基本原则（这些可以在“进一步探索”中找到）。值得重复的一个总原则是***分析（profiling）的绝对重要性***。在没有分析的情况下，程序员往往会犯两种类型的错误。
- 首先，他们优化了错误的代码。程**序的大部分不是性能关键，所以花时间加速它们是浪费的**。*关于哪个代码是性能关键的直觉是不可信的——只有通过直接测量才能确定*
- 其次，程序员有时会做出“优化”实际上会减慢代码速度。**这个问题在 C++中尤其突出，因为一句看似简单的代码实际上可能会生成大量的机器代码**。 检查你的编译器输出，并经常进行性能分析。
### 对象的构造和析构
这是一个核心概念，同时是编译器在后台生成机器码的主要部分。对于设计不良的程序来说，其在这个阶段会花费大量的时间来调用析构函数，以及构建临时对象。下面几个常识可以有效地让你在面对对象密集型的代码时能够保证代码运行速度接近于C:

- 延迟对象的构造，直到它们需要时再进行
**最快的代码就是那永远不执行的代码**
```C++
void Function(int arg)
{
	Object obj;
	if(arg *=0)
		return;
		...
}
```
即使 arg 为零，我们也要支付调用 Object 的构造函数和析构函数的成本。如果 arg 经常为零，尤其是如果 Object 本身分配内存，这种浪费可能会迅速累积。
解决方案是将 **obj 的声明移到 //check 之后**。
> 要注意在循环中声明非平凡的对象。如果你延迟对象的构造直到它在循环中需要时，你将支付每次迭代时对象构造和销毁的成本。**最好在循环之前声明对象，并且只支付这些成本一次**。*如果一个函数在内部循环中被调用，并且该函数在栈上创建一个对象，你可以选择在循环外部创建该对象，并将其作为引用传递给函数*。

- 使用初始化列表
考虑以下类：
```C++
class Vehicle
{
	public: 
		Vehicle(const std::string &name)//最好不要这么做
{
	mName=name;
	
}
	private:
	std::string mName;
	
};
```
因为成员变量在构造函数体被调用之前就已经被构造了，因此这段代码会调用`string mName`的构造函数，然后调用赋值运算符来复制对象的名字。但是十分糟糕的是，使用`string`默认构造函数
很可能会分配内存——实际上，分配的内存可能比存储在`Vehicle`构造函数中实际变量名所需的内存还要多。
> 此外，如果提供更多信息（在这个例子中是实际要存储的字符串），非默认的 string 构造函数通常可以更高效，编译器甚至可能优化掉空的 Vehicle 构造函数调用：

这里是优化后的版本代码：
```C++
class Vehicle{
	public: 
		Vehicle(const std::string &name) :mName(name)
		{}
	private:
	std::string mName;
};
```
- 建议使用前置自增而不是后置自增
写 x = y++ 的问题在于，*自增函数必须先复制 y 的原始值，然后自增 y，并返回原始值*。因此，后置自增涉及创建临时对象，而前置自增则不涉及。对于整数，没有额外的开销，但对于用户定义的类型，这是浪费。只要有可能，你应该使用前置自增。在 for 循环迭代器中，你几乎总是有这个选择。
- 避免使用返回值类型的运算符
在C++中编写向量加法的标准方法为：
```C++
Vector operator+ (const Vector &v1,const Vector &v2)
```
此运算符必须返回一个新的 Vector 对象，并且它必须通过值返回。虽然这允许像 v = v1 + z>2 这样有用且可读的表达式，但临时构建和 Vector 复制成本通常太高，对于像向量加法这样经常调用的操作来说。有时可以安排代码，以便编译器能够优化掉临时对象(这称为"返回值优化")，但是在一般情况下，最好忍痛放弃，编写稍微”丑陋“但是通常更快的代码：
```C++
void Vector::Add(const Vector &v1, const Vector &v2)
```
> 注意，***perator+=不受同样问题的困扰，因为它在原地修改第一个参数，并且不需要返回临时对象。因此，在可能的情况下，你应该使用+=运算符而不是+***

- 使用轻量级的构造函数
对于前面的Vector类的构造函数，不应该对其元素初始化为零应该在真正需要初始化的地方再进行初始化。
一个好的编译器可能会消除一些额外的代码，但为什么要冒险呢？作为一个一般规则，您希望对象构造函数初始化它的每个成员变量，因为未初始化的数据会导致微妙的问题。然而，对于经常作为临时实例的小类，您应该准备好为了性能而妥协这个规则。在许多游戏中，候选者是 Vector 和 Matrix 类。这些类应该提供方法（或替代构造函数）来将它们设置为零和单位，*但默认构造函数应该是空的*。
作为这一原则的推论，你应该为类提供额外的构造函数，如果我们的第二个示例中的Vehicle类是这样写的：
```C++
clasws Vehicle{
public:
Vehicle(){
}
void SetName(const std::string &name)
{
mName=name;
}
private:
	std::string mName;
};
```
我们将承担构造 mName 的成本，然后通过 `SetName()`再次设置它
- 预分配并缓存对象
一个游戏通常会有一些频繁分配和释放的类。在C的游戏中，通常会预先分配一个大的数组，并且在需要的时候使用它们。通过一点规划，你可以在C++中做同样的事情。***其思想是，不要不断地构造和销毁对象，而是请求新的对象并将旧的对象返回到缓存中。缓存可以作为模板实现，这样它就可以适用于任何类，前提是该类有一个默认构造函数。示例缓存类模板的代码在随附的 CD 上。***
你可以选择*按需分配对象来填充缓存，或者预先分配所有对象*。如果此外你还对对象维护栈规范（这意味着在你删除对象 X 之前，你首先删除所有在 X 之后分配的对象），你可以在连续的内存块中分配缓存。
C++应用程序通常需要比 C 应用程序更关注内存管理的细节。在 C 中，所有分配都是显式的，通过 mallocQ 和 freeQ 进行，*而 C++可以在构造临时对象和成员变量时隐式分配内存*。大多数 C++游戏（就像大多数 C 游戏一样）将需要自己的内存管理器
由于 C++游戏可能会执行许多分配，因此必须特别小心地防止堆碎片化。一个选项是采取传统方法之一：
***要么在游戏启动后不分配任何内存，要么维护一个大的连续内存块，该内存块定期释放***
1. 重载全局的`new`和`delete`运算符。使用自定义的运算符来实现来将游戏最常见的分配从`mallocQ`转移到预分配的内存块中
2. 为了跟踪哪些块是空闲的，通过将每个空闲块指向下一个空闲块来维护一个空闲列表。在分配时，从列表中移除前面的块，在释放时，将释放的块添加到列表的前面。

#### 虚函数
虚函数常常被认为是消耗性能的神秘特性，因为从概念上来讲，为了再一个对象上生成一个虚函数调用，那么编译器会访问该对象的虚函数表，并获取指向该成员函数的指针，设置调用然后跳转到该成员函数的地址。
这需要与 C 语言中的函数调用进行比较，在 C 语言中，*编译器设置调用并跳转到固定地址。虚函数调用的额外开销是到虚函数表的间接引用；由于调用地址事先未知，还可能存在处理器指令缓存未命中的惩罚。*

解决方法：**在性能关键区域避免这些调用**
```C++
class BaseClass
{
	public:
	virtual char *GetPointer()=0;
};
class Class"! : public BaseClass
{ 
	virtual char *GetPointer();
};
class Class2 : public BaseClass
{ 
	virtual char *GetPointer();
}|
void Function(BaseClass *pObj)
{ 
	char *ptr = pObj->GetPointer();
}
```
在上述函数中，如果FunctionQ对于性能至关重要，则需要将`BaeseClass::GetPointer`的调用从虚函数改为内联函数。****一种方法是向`BaseClass`添加一个新的受保护数据成员，并在每个类中设置该类数据成员***:
```C++
class BaseClass 
{
	public:
		inline char *GetPointerFast(){
			return mPointer;
		}
		protected:
			inline void SetPointer(char *pData)
			{
			mpData=pData;
			}
			private:
				char *mpData;
};
//类 class1 和类 class2 在成员函数中根据需要调用 SetPointer 
void Function(BaseClass *pObj)
{
	char *ptr =pObj-> GetPointerFast();
}
```
如果 `Classl` 和 `Class2` 只有细微的差别，将它们合并为一个类，通过一个标志在运行时决定类的行为方式，可能是一个更激进的措施。*这样做的改变（以及删除纯虚基类 BaseClass）可以使上一个示例中的 GetPointer 函数再次内联。这种转变远非优雅，但在小缓存的机器上的内层循环中，为了消除虚函数调用，你愿意做更糟糕的事情*。
> 尽管每个新的虚函数只增加了一个指针的大小到每个类的表中（通常是一个可以忽略的成本），但在类中的虚函数 yzrtf 需要在每个对象的基础上指向虚函数表。这意味着在小且经常使用的类中，你根本不希望有任何虚函数，因为这额外的开销是不可接受的。由于继承通常需要使用一个或多个虚函数（至少需要一个虚析构函数），对于小且频繁使用的对象，你也不想有任何层次结构。

#### 代码尺寸

